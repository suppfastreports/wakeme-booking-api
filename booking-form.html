<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WakeMe - Онлайн запись</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Unbounded:wght@200;300;400;500;600;700;800;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            margin: 0;
            padding: 0;
            outline: none;
            border: none;
        }

        body {
            font-family: 'Unbounded', sans-serif;
            background: white;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            outline: none;
            border: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .location-section {
            grid-column: 1;
        }

        .calendar-section {
            grid-column: 2;
        }

        .service-section {
            grid-column: 3;
        }

        .time-section {
            grid-column: 4;
            padding-top: 10px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s ease;
        }


        .location-options {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .location-btn {
            padding: 12px 16px;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .location-btn:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .location-btn.selected {
            background: #64D7F2;
            color: white;
        }

        .location-btn.selected .location-name {
            color: white;
        }

        .location-btn.selected .feature-item {
            color: rgba(255, 255, 255, 0.9);
        }

        .location-name {
            font-family: 'Unbounded', sans-serif;
            font-size: 12px;
            font-weight: 500;
            color: #2c2c2c;
            margin-bottom: 4px;
        }

        .location-address {
            font-family: 'Unbounded', sans-serif;
            font-size: 11px;
            font-weight: 300;
            color: #666;
        }

        .location-features {
            margin-top: 8px;
        }

        .feature-item {
            font-family: 'Unbounded', sans-serif;
            font-size: 9px;
            font-weight: 300;
            color: #666;
            line-height: 1.4;
            margin-bottom: 2px;
        }

        .feature-item:last-child {
            margin-bottom: 0;
        }

        .feature-item em {
            font-style: italic;
        }

        .location-map {
            width: 100%;
            height: 200px;
            background: #f8f9fa;
            border-radius: 12px;
            margin-top: 16px;
            position: relative;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }

        .map-pin {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: #ff4444;
            border-radius: 50% 50% 50% 0;
            transform: translate(-50%, -50%) rotate(-45deg);
        }

        .map-pin::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        .map-fullscreen {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            color: #666;
        }

        .duration-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .duration-option {
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            background: white;
        }

        .duration-option:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .duration-option.selected {
            background: #64D7F2;
            color: white;
        }

        .duration-option.selected .duration-price {
            color: rgba(255, 255, 255, 0.9);
        }

        .duration-option.selected .duration-time {
            color: white;
        }

        .duration-time {
            font-size: 14px;
            font-weight: 500;
            color: #2c2c2c;
            margin-bottom: 2px;
        }

        .duration-price {
            font-size: 12px;
            font-weight: 500;
            color: #999;
        }

        .section-divider {
            height: 1px;
            background: #e9ecef;
            margin: 16px 0;
        }

        .trainer-options {
            display: flex;
            flex-direction: row;
            gap: 8px;
            width: 100%;
        }

        .trainer-btn {
            font-family: 'Unbounded', sans-serif;
            padding: 12px 16px;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 11px;
            font-weight: 400;
            margin-bottom: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            width: 100%;
            min-height: 60px;
            color: #64D7F2;
        }

        .trainer-btn span { white-space: nowrap; }

        .trainer-btn:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .trainer-btn.selected {
            background: #64D7F2;
            color: white;
        }

        .trainer-price {
            font-size: 12px;
            font-weight: 500;
            color: #999;
            margin-top: 2px;
        }

        .trainer-btn.selected .trainer-price {
            color: rgba(255, 255, 255, 0.8);
        }


        .booking-form {
            background: #f8f9fa;
            border-radius: 16px;
            padding: 30px;
            margin-top: -20px;
        }

        .form-header {
            text-align: left;
            margin-bottom: 20px;
        }

        .form-title {
            font-family: 'Unbounded', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .form-description {
            font-family: 'Unbounded', sans-serif;
            font-size: 12px;
            font-weight: 400;
            color: #666;
            margin-bottom: 24px;
        }

        /* Popup Styles */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .popup-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .popup {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .popup-overlay.show .popup {
            transform: scale(1);
        }

        .popup-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }

        .popup-icon.success {
            background: #d4edda;
            color: #155724;
        }

        .popup-icon.error {
            background: #f8d7da;
            color: #721c24;
        }

        .popup-title {
            font-family: 'Unbounded', sans-serif;
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .popup-message {
            font-family: 'Unbounded', sans-serif;
            font-size: 14px;
            font-weight: 400;
            color: #666;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .popup-button {
            font-family: 'Unbounded', sans-serif;
            background: #64D7F2;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .popup-button:hover {
            background: #4BC5E8;
        }

        .booking-form form {
            display: flex;
            gap: 8px;
            align-items: center;
            width: 100%;
            align-items: stretch;
        }

        .form-group {
            flex: 0.8;
            margin-bottom: 0;
            display: flex;
            align-items: center;
        }

        .booking-btn {
            flex-shrink: 0;
            width: 250px;
            height: 48px;
            padding: 0 32px;
            margin: 0;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }



        .form-group {
            margin-bottom: 20px;
        }


        .form-input {
            font-family: 'Unbounded', sans-serif;
            width: 100%;
            padding: 0 16px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 400;
            transition: all 0.2s;
            background: white;
            height: 48px;
            margin: 0;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            background: white;
        }

        .form-input::placeholder {
            font-size: 12px;
            font-weight: 300;
            color: #999;
        }

        .booking-btn {
            font-family: 'Unbounded', sans-serif;
            background: #64D7F2;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 400;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .booking-btn:hover {
            background: #4BC5E8;
        }

        .booking-btn:focus {
            outline: none;
        }

        /* Убираем обводки со всех кнопок при фокусе */
        button:focus {
            outline: none;
        }

        /* Убираем все обводки с input и button */
        input, button {
            border: none !important;
            outline: none !important;
        }

        .booking-form * {
            box-sizing: border-box;
        }

        .booking-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .time-slots-grid-section {
            margin-top: 20px;
        }

        .time-slots-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 16px;
        }

        .time-slot {
            padding: 12px 8px;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
            background: white;
        }

        .time-slot:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .time-slot.selected {
            background: #64D7F2;
            color: white;
        }

        .time-slot.unavailable {
            background: #f5f5f5;
            color: #ccc;
            cursor: not-allowed;
        }

        /* Skeleton loading animation */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 8px;
        }

        @keyframes skeleton-loading {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }

        .time-slot.skeleton {
            height: 48px;
            margin-bottom: 8px;
        }

        .calendar-date.skeleton {
            height: 32px;
            width: 32px;
            border-radius: 50%;
        }

        /* Плавные переходы для дат календаря */
        .calendar-date {
            transition: all 0.3s ease;
        }

        .calendar-date.skeleton {
            transition: all 0.2s ease;
        }

        .calendar-date:not(.skeleton) {
            transition: all 0.3s ease;
        }

        .total-info {
            background: rgba(100, 215, 242, 0.05);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            text-align: center;
        }

        .total-amount {
            font-size: 24px;
            font-weight: 700;
            color: #64D7F2;
            margin-bottom: 4px;
        }

        .total-details {
            font-size: 14px;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            text-align: center;
            padding: 20px;
            color: #ff4444;
            background: #fff5f5;
            border-radius: 8px;
        }

        .form-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            width: 100%;
            height: 100%;
            min-height: 200px;
        }

        .form-error-icon {
            font-size: 32px;
            margin-bottom: 16px;
            text-align: center;
        }

        .form-error-title {
            font-family: 'Unbounded', sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
        }

        .form-error-description {
            font-family: 'Unbounded', sans-serif;
            font-size: 10px;
            font-weight: 400;
            color: #666;
            text-align: center;
        }

        /* Calendar Styles */

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .calendar-nav {
            background: #f8f9fa;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-nav:hover {
            background: #64D7F2;
            color: white;
        }

        .calendar-month {
            font-size: 14px;
            font-weight: 500;
            color: #2c2c2c;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        .calendar-day {
            text-align: center;
            padding: 6px 2px;
            font-size: 11px;
            color: #999;
            font-weight: 500;
        }

        .calendar-date {
            text-align: center;
            padding: 6px 2px;
            font-size: 12px;
            color: #2c2c2c;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 400;
        }

        .calendar-date:hover {
            background: rgba(100, 215, 242, 0.1);
        }

        .calendar-date.selected {
            background: #64D7F2;
            color: white;
        }

        .calendar-date.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            color: #999;
            background: transparent;
        }

        .calendar-date.disabled:hover {
            background: transparent;
        }

        .calendar-date.no-slots {
            color: #999;
            opacity: 0.5;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .calendar-date.no-slots:hover {
            background: #f5f5f5;
        }

        .calendar-date.other-month {
            color: #999;
            cursor: not-allowed;
            opacity: 0.3;
        }

        .calendar-date.other-month:hover {
            background: transparent;
            transform: none;
        }

        /* Mobile styles */
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .location-section {
                grid-column: 1;
            }

            .calendar-section {
                grid-column: 2;
            }

            .service-section {
                grid-column: 1;
            }

            .time-section {
                grid-column: 2;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 5%;
                max-width: 90%;
            }
            
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .location-section,
            .calendar-section,
            .service-section,
            .time-section {
                grid-column: 1;
            }
            
            /* Секция времени теперь работает с реальным API */

            .duration-options {
                grid-template-columns: 1fr 1fr;
            }

            .time-slots-grid {
                grid-template-columns: 1fr 1fr;
            }

            .booking-form form {
                flex-direction: column;
                gap: 16px;
                align-items: center;
            }

            .form-group {
                margin-bottom: 16px;
                min-width: auto;
                width: 100%;
            }

            .booking-btn {
                min-width: auto;
                width: 100%;
                max-width: 300px;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .container {
                padding: 0 2%;
                max-width: 95%;
            }
            
            .duration-options {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Main Content -->
        <div class="main-content">
            <!-- Location Selection -->
            <div class="section location-section">
                <div class="location-options">
                    <button class="location-btn selected" data-location="DUBAI_HARBOUR_MARINA">
                        <div class="location-name">Marina Harbour</div>
                        <div class="location-features">
                            <div class="feature-item">• удобное расположение в центре города</div>
                            <div class="feature-item">• вид на колесо обозрения Ain Dubai, JBR и Address Beach Residences</div>
                            <div class="feature-item">• кристально-голубая вода</div>
                        </div>
                    </button>
                    <button class="location-btn" data-location="DUBAI_CREEK_HARBOUR">
                        <div class="location-name">Creek Harbour</div>
                        <div class="location-features">
                            <div class="feature-item">• локация без сторонних волн</div>
                            <div class="feature-item">• закат с видом на <em>Burj Khalifa</em></div>
                            <div class="feature-item">• нет <em>Jet Ski</em></div>
                        </div>
                    </button>
                </div>
            </div>

            <!-- Calendar Section -->
            <div class="section calendar-section">
                <div class="calendar-header">
                    <button class="calendar-nav" onclick="changeMonth(-1)">‹</button>
                    <div class="calendar-month">Октябрь 2025</div>
                    <button class="calendar-nav" onclick="changeMonth(1)">›</button>
                </div>
                <div class="calendar-grid">
                    <!-- Calendar days and dates will be dynamically generated by JS -->
                </div>
            </div>

            <!-- Service & Trainer Selection -->
            <div class="section service-section">
                <div class="duration-options">
                    <div class="duration-option" data-duration="30">
                        <div class="duration-time">30 мин</div>
                        <div class="duration-price">390 AED</div>
                    </div>
                    <div class="duration-option" data-duration="45">
                        <div class="duration-time">45 мин</div>
                        <div class="duration-price">565 AED</div>
                    </div>
                    <div class="duration-option" data-duration="60">
                        <div class="duration-time">60 мин</div>
                        <div class="duration-price">750 AED</div>
                    </div>
                    <div class="duration-option" data-duration="90">
                        <div class="duration-time">90 мин</div>
                        <div class="duration-price">1 125 AED</div>
                    </div>
                    <div class="duration-option" data-duration="120">
                        <div class="duration-time">120 мин</div>
                        <div class="duration-price">1 500 AED</div>
                    </div>
                </div>
                
                <div class="section-divider"></div>
                
                <div class="trainer-options">
                    <button class="trainer-btn" data-trainer="with">
                        <span>С тренером</span>
                        <span class="trainer-price" id="trainerPrice">+COACH</span>
                    </button>
                    <button class="trainer-btn" data-trainer="without">
                        <span>Без тренера</span>
                    </button>
                </div>
            </div>

            <!-- Time Selection -->
            <div class="section time-section">
                <div class="time-slots-grid" id="timeSlots">
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                </div>
            </div>
        </div>


        <!-- Booking Form -->
        <div class="booking-form">
            <div class="form-header">
                <div class="form-title">Заполните форму</div>
                <div class="form-description">Мы свяжемся с вами в WhatsApp для подтверждения даты</div>
            </div>
            <form id="bookingForm">
                <div class="form-group">
                    <input type="text" id="clientName" class="form-input" required placeholder="Имя">
                </div>
                
                <div class="form-group">
                    <input type="tel" id="clientPhone" class="form-input" required placeholder="Телефон">
                </div>
                
                <button type="submit" class="booking-btn" id="bookingBtn">
                    Забронировать
                </button>
            </form>
        </div>
    </div>

    <!-- Popup -->
    <div class="popup-overlay" id="popupOverlay">
        <div class="popup">
            <div class="popup-icon" id="popupIcon"></div>
            <div class="popup-title" id="popupTitle"></div>
            <div class="popup-message" id="popupMessage"></div>
            <button class="popup-button" id="popupButton">Продолжить</button>
        </div>
    </div>

    <script>
        // API Configuration
        const API_CONFIG = {
            proxyUrl: 'https://wakeme-booking-api-production.up.railway.app',
            companyId: 1252189,
            locations: {
                'DUBAI_HARBOUR_MARINA': {
                    staffId: 2742288,
                    services: {
                        30: 12199769,   // 30 MIN (+20 min of mooring)
                        45: 12952120,   // 45 MIN (+20 min of mooring)
                        60: 12200654,   // 60 MIN (+20 min of mooring)
                        90: 12200653,   // 90 MIN (+20 min of mooring)
                        120: 12203754   // 120 MIN (+20 min of mooring)
                    }
                },
                'DUBAI_CREEK_HARBOUR': {
                    staffId: 2780637,
                    services: {
                        30: 12396457,   // 30 MIN + COACH (+10 min of mooring)
                        45: 12952179,   // 45 MIN + COACH (+10 min of mooring)
                        60: 12396432,   // 60 MIN + COACH (+10 min of mooring)
                        90: 12396453,   // 90 MIN + COACH (+10 min of mooring)
                        120: 12396454   // 120 MIN + COACH (+10 min of mooring)
                    }
                }
            }
        };

        // Price configuration
        const PRICES = {
            30: { base: 390, withTrainer: 540 },
            45: { base: 565, withTrainer: 790 },
            60: { base: 750, withTrainer: 1050 },
            90: { base: 1125, withTrainer: 1575 },
            120: { base: 1500, withTrainer: 2100 }
        };

        // Telegram Bot Configuration (используется только на серверном вебхуке после оплаты)
        const TELEGRAM_BOT_TOKEN = 'YOUR_BOT_TOKEN_HERE';
        const TELEGRAM_CHAT_ID = 'YOUR_CHAT_ID_HERE';

        // Кэш для хранения ближайших доступных дат
        const availableDatesCache = new Map();
        
        // Глобальная переменная для хранения ближайших доступных дат
        let nearestAvailableDates = new Map();
        
        // Переменная для сохранения даты при смене услуги/локации
        let savedDate = null;

        // Получить ближайшие доступные слоты для локации
        async function getNearestAvailableSlots(locationKey, serviceId) {
            const cacheKey = `${locationKey}_${serviceId}`;
            
            // Проверяем кэш
            if (availableDatesCache.has(cacheKey)) {
                return availableDatesCache.get(cacheKey);
            }

            try {
                const staffId = API_CONFIG.locations[locationKey].staffId;
                const url = `${API_CONFIG.proxyUrl}/api/nearest-slots?companyId=${API_CONFIG.companyId}&staffId=${staffId}&serviceId=${serviceId}`;
                
                
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Кэшируем результат
                    availableDatesCache.set(cacheKey, data);
                    return data;
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                return null;
            }
        }

        // Проверить, нужно ли заблокировать дату (до ближайшего доступного слота)
        function isDateBeforeNearestAvailable(dateString) {
            const selectedLocation = getSelectedLocation();
            const selectedDuration = getSelectedDuration();
            const cacheKey = `${selectedLocation}_${selectedDuration}`;
            
            
            if (!nearestAvailableDates.has(cacheKey)) {
                return false; // Если нет данных, не блокируем
            }
            
            const nearestData = nearestAvailableDates.get(cacheKey);
            if (!nearestData || !nearestData.data || !nearestData.data.seance_date) {
                return false;
            }
            
            // Извлекаем только дату из ISO строки (убираем время)
            const nearestDateStr = nearestData.data.seance_date.split('T')[0];
            const checkDateStr = dateString;
            
            
            // Блокируем даты до ближайшего доступного слота (сравниваем строки дат)
            const shouldBlock = checkDateStr < nearestDateStr;
            
            return shouldBlock;
        }

        // Загрузить ближайшие доступные даты для всех локаций и услуг
        async function loadNearestAvailableDates() {
            
            for (const locationKey of Object.keys(API_CONFIG.locations)) {
                
                for (const duration of Object.keys(API_CONFIG.locations[locationKey].services)) {
                    const serviceId = API_CONFIG.locations[locationKey].services[duration];
                    const cacheKey = `${locationKey}_${duration}`;
                    
                    
                    try {
                        const data = await getNearestAvailableSlots(locationKey, serviceId);
                        
                        if (data && data.success) {
                            nearestAvailableDates.set(cacheKey, data);
                        } else {
                        }
                    } catch (error) {
                    }
                }
            }
            
        }

        // Load time slots from API
        async function loadTimeSlots() {
            const timeSlots = document.querySelector('.time-section .time-slots-grid');
            if (!timeSlots) return;
            
            // Показываем скелет анимацию
            timeSlots.innerHTML = `
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
            `;
            
            // Показываем скелетон сразу, без задержки
            requestAnimationFrame(async () => {
                try {
                    const selectedDate = getCurrentDate();
                    
                    // Используем унифицированный адаптер
                    const slots = await fetchSlots(selectedDate, { signal: new AbortController().signal });
                    renderTimeSlots(slots);
                    
                } catch (error) {
                    const timeSlots = document.querySelector('.time-section .time-slots-grid');
                    if (timeSlots) {
                        timeSlots.innerHTML = `<div class="error">Ошибка загрузки слотов: ${error.message}</div>`;
                    }
                }
            }); // Показываем скелетон сразу через requestAnimationFrame
        }

        // Display time slots
        // displayTimeSlots удалена - теперь везде используется renderTimeSlots с унифицированным контрактом Slot[]

        // Helper functions
        function getSelectedDuration() {
            const selectedDuration = document.querySelector('.duration-option.selected');
            return parseInt(selectedDuration.dataset.duration);
        }

        function getSelectedLocation() {
            const selectedLocationBtn = document.querySelector('.location-btn.selected');
            return selectedLocationBtn.dataset.location;
        }

        function getServiceIdForLocation(locationKey, durationId) {
            return API_CONFIG.locations[locationKey].services[durationId];
        }

        function getStaffIdForLocation(locationKey) {
            return API_CONFIG.locations[locationKey].staffId;
        }

        // Calculate total price
        function calculateTotalPrice() {
            const duration = getSelectedDuration();
            const trainer = getSelectedTrainer();
            
            if (!PRICES[duration]) {
                return 0;
            }
            
            let price;
            if (trainer === 'with') {
                price = PRICES[duration].withTrainer;
            } else {
                price = PRICES[duration].base;
            }
            
            // Форматируем число с пробелами для тысяч
            return price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        }

        // Update trainer price display
        function updateTrainerPrice() {
            const duration = getSelectedDuration();
            const trainerPriceElement = document.getElementById('trainerPrice');
            
            if (trainerPriceElement && PRICES[duration]) {
                const basePrice = PRICES[duration].base;
                const withTrainerPrice = PRICES[duration].withTrainer;
                const difference = withTrainerPrice - basePrice;
                
                // Форматируем число с пробелами для тысяч
                const formattedDifference = difference.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
                trainerPriceElement.textContent = `+${formattedDifference} AED`;
            }
        }

        // Popup functions
        function showPopup(type, title, message) {
            const overlay = document.getElementById('popupOverlay');
            const icon = document.getElementById('popupIcon');
            const titleEl = document.getElementById('popupTitle');
            const messageEl = document.getElementById('popupMessage');
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // Set icon and style
            if (type === 'success') {
                icon.textContent = '✓';
                icon.className = 'popup-icon success';
            } else {
                icon.textContent = '✕';
                icon.className = 'popup-icon error';
            }
            
            // Show popup
            overlay.classList.add('show');
        }

        function hidePopup() {
            const overlay = document.getElementById('popupOverlay');
            overlay.classList.remove('show');
        }

        function getSelectedTrainer() {
            const selectedTrainer = document.querySelector('.trainer-btn.selected');
            return selectedTrainer.dataset.trainer;
        }

        function getCurrentDate() {
            const selectedDateElement = document.querySelector('.calendar-date.selected');
            if (selectedDateElement && selectedDateElement.dataset.date) {
                // Убеждаемся, что дата в правильном формате YYYY-MM-DD
                const dateStr = selectedDateElement.dataset.date;
                return dateStr;
            }
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            return todayStr;
        }

        function getSelectedTimeSlot() {
            const selectedSlot = document.querySelector('.time-slot.selected');
            return selectedSlot ? selectedSlot.dataset.time : null;
        }

        // Создание Stripe Checkout сессии и редирект
        async function redirectToStripeCheckout(bookingData) {
            // Преобразуем total "1 197" -> 1197
            const amountAed = Number(String(bookingData.total).replace(/\s/g, ''));

            const payload = {
                name: bookingData.name,
                phone: bookingData.phone,
                location: bookingData.location,
                duration: bookingData.duration,
                trainer: bookingData.trainer,
                time: bookingData.time,
                date: bookingData.date,
                amount_aed: amountAed
            };

            // Клиентский лог
            try {
                fetch(`${API_CONFIG.proxyUrl}/api/logs`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ level: 'info', message: 'create-checkout-session:start', data: payload })
                });
            } catch (e) {}

            const response = await fetch(`${API_CONFIG.proxyUrl}/api/create-checkout-session`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const text = await response.text();
                try {
                    fetch(`${API_CONFIG.proxyUrl}/api/logs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ level: 'error', message: 'create-checkout-session:failed', data: { status: response.status, body: text } })
                    });
                } catch (e) {}
                throw new Error(text || 'Не удалось создать сессию Stripe');
            }

            const data = await response.json();
            if (data && data.url) {
                window.location.href = data.url;
            } else {
                try {
                    fetch(`${API_CONFIG.proxyUrl}/api/logs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ level: 'error', message: 'create-checkout-session:no-url', data: data })
                    });
                } catch (e) {}
                throw new Error('Не удалось получить URL Stripe');
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Popup button handler
            document.getElementById('popupButton').addEventListener('click', hidePopup);
            document.getElementById('popupOverlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    hidePopup();
                }
            });
            // Duration selection
            document.querySelectorAll('.duration-option').forEach(option => {
                option.addEventListener('click', function() {
                    
                    document.querySelectorAll('.duration-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    updateTrainerPrice(); // Обновляем цену тренера
                    clearAvailabilityCache(); // Очищаем кеш доступности при смене услуги
                    
                    // НОВАЯ АРХИТЕКТУРА: Событийная синхронизация
                    const selectedDuration = getSelectedDuration();
                    const selectedLocation = getSelectedLocation();
                    const cacheKey = `${selectedLocation}_${selectedDuration}`;
                    
                    
                    onServiceOrLocationChange({
                        cacheKey,
                        fetchAvailability,
                        renderCalendar: renderCalendarFromData,
                        highlightDate,
                        fetchSlots: loadSlotsSafe
                    });
                });
            });

            // Trainer selection
            document.querySelectorAll('.trainer-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.trainer-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });

            // Location selection
            document.querySelectorAll('.location-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    
                    document.querySelectorAll('.location-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    clearAvailabilityCache(); // Очищаем кеш доступности при смене локации
                    
                    // НОВАЯ АРХИТЕКТУРА: Событийная синхронизация
                    const selectedDuration = getSelectedDuration();
                    const selectedLocation = getSelectedLocation();
                    const cacheKey = `${selectedLocation}_${selectedDuration}`;
                    
                    
                    onServiceOrLocationChange({
                        cacheKey,
                        fetchAvailability,
                        renderCalendar: renderCalendarFromData,
                        highlightDate,
                        fetchSlots: loadSlotsSafe
                    });
                });
            });


            // Booking form submission
            document.getElementById('bookingForm').addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const selectedTime = getSelectedTimeSlot();
                if (!selectedTime) {
                    showPopup('error', 'Выберите время', 'Пожалуйста, выберите время для бронирования');
                    return;
                }

                const bookingData = {
                    name: document.getElementById('clientName').value,
                    phone: document.getElementById('clientPhone').value,
                    location: getSelectedLocation(),
                    duration: getSelectedDuration(),
                    trainer: getSelectedTrainer(),
                    time: selectedTime,
                    date: getCurrentDate(),
                    total: calculateTotalPrice()
                };

                const bookingBtn = document.getElementById('bookingBtn');
                bookingBtn.disabled = true;
                bookingBtn.textContent = 'Отправка...';

                try {
                    await redirectToStripeCheckout(bookingData);
                } catch (error) {
                    showPopup('error', 'Ошибка оплаты', error.message || 'Не удалось перейти к оплате');
                } finally {
                    bookingBtn.disabled = false;
                    bookingBtn.textContent = 'Забронировать';
                }
            });
        });

        // Calendar variables
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();
        
        // Cache for date availability
        let dateAvailabilityCache = new Map();
        
        // Clear availability cache when location or service changes
        function clearAvailabilityCache() {
            dateAvailabilityCache.clear();
            // Также очищаем кэш ближайших дат
            nearestAvailableDates.clear();
            availableDatesCache.clear();
        }
        
        // Check if slots are available for a specific date
        async function checkDateAvailability(dateString) {
            
            // Check cache first
            if (dateAvailabilityCache.has(dateString)) {
                const cached = dateAvailabilityCache.get(dateString);
                return cached;
            }
            
            try {
                const locationKey = getSelectedLocation();
                const durationId = getSelectedDuration();
                const serviceId = getServiceIdForLocation(locationKey, durationId);
                const staffId = getStaffIdForLocation(locationKey);
                const companyId = API_CONFIG.companyId;
                
                const response = await fetch(`${API_CONFIG.proxyUrl}/api/slots?companyId=${companyId}&staffId=${staffId}&serviceId=${serviceId}&date=${dateString}`);
                
                if (!response.ok) {
                    // Для ошибок 422 (нет слотов) и других ошибок считаем дату недоступной
                    dateAvailabilityCache.set(dateString, false);
                    return false;
                }
                
                const data = await response.json();
                const hasSlots = data.success && data.data && Array.isArray(data.data) && data.data.length > 0;
                
                
                // Cache the result
                dateAvailabilityCache.set(dateString, hasSlots);
                return hasSlots;
                
            } catch (error) {
                // При любой ошибке считаем дату недоступной
                dateAvailabilityCache.set(dateString, false);
                return false;
            }
        }

        // Calendar navigation
        function changeMonth(direction) {
            
            // Сохраняем текущую выбранную дату
            const currentSelectedDate = document.querySelector('.calendar-date.selected');
            const selectedDate = currentSelectedDate ? currentSelectedDate.dataset.date : null;
            
            const today = new Date();
            const currentDate = new Date(currentYear, currentMonth);
            const todayDate = new Date(today.getFullYear(), today.getMonth());
            
            currentMonth += direction;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            } else if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            }
            
            // Check if we're trying to go to a past month
            const newDate = new Date(currentYear, currentMonth);
            if (newDate < todayDate) {
                // Revert the change
                currentMonth -= direction;
                if (currentMonth < 0) {
                    currentMonth = 11;
                    currentYear--;
                } else if (currentMonth > 11) {
                    currentMonth = 0;
                    currentYear++;
                }
                return; // Don't render if we can't go to past month
            }
            
            
            // Получаем данные для нового месяца
            const selectedDuration = getSelectedDuration();
            const selectedLocation = getSelectedLocation();
            const cacheKey = `${selectedLocation}_${selectedDuration}`;
            
            // Показываем скелет сразу
            const calendarGrid = document.querySelector('.calendar-grid');
            if (calendarGrid) {
                calendarGrid.innerHTML = '';
                const firstDayOfMonth = new Date(currentYear, currentMonth, 1).getDay();
                const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
                
                // Создаем пустые ячейки для начала месяца
                for (let i = 0; i < firstDayOfMonth; i++) {
                    const emptyCell = document.createElement('div');
                    emptyCell.className = 'calendar-date empty';
                    calendarGrid.appendChild(emptyCell);
                }
                
                // Создаем даты со скелетом СРАЗУ (БЕЗ ТЕКСТА - только блюренные круги)
                for (let i = 1; i <= daysInMonth; i++) {
                    const dateElement = document.createElement('div');
                    dateElement.className = 'calendar-date skeleton';
                    // НЕ добавляем textContent - только скелет
                    calendarGrid.appendChild(dateElement);
                }
            }
            
            // Также показываем скелет для времени при смене месяца
            const timeSlotsContainer = document.querySelector('.time-slots-grid');
            if (timeSlotsContainer) {
                timeSlotsContainer.innerHTML = '';
                
                // Создаем 3-4 скелета для времени
                for (let i = 0; i < 4; i++) {
                    const skeletonSlot = document.createElement('div');
                    skeletonSlot.className = 'time-slot skeleton';
                    timeSlotsContainer.appendChild(skeletonSlot);
                }
            }
            
            // Загружаем данные для нового месяца
            fetchAvailability({ signal: new AbortController().signal }).then(availability => {
                renderCalendarFromData(availability);
            }).catch(error => {
                // Fallback - показываем ошибку
                const calendarGrid = document.querySelector('.calendar-grid');
                if (calendarGrid) {
                    calendarGrid.innerHTML = `
                        <div class="form-error">
                            <div class="form-error-icon">⚠️</div>
                            <div class="form-error-title">Ошибка загрузки</div>
                            <div class="form-error-description">Не удалось загрузить календарь</div>
                        </div>
                    `;
                }
            });
            
            // Новая система не требует ожидания - все работает через Promise.all в renderCalendarFromData
        }

        // renderCalendar удалена - используется только renderCalendarFromData
        function renderCalendar() {
            return;
            const calendarGrid = document.querySelector('.calendar-grid');
            const calendarMonthDisplay = document.querySelector('.calendar-month');
            
            if (!calendarGrid || !calendarMonthDisplay) {
                return;
            }
            
            calendarGrid.innerHTML = ''; // Очищаем перед показом скелета
            // Показываем скелет анимацию для календаря
            calendarGrid.innerHTML = `
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
            `;

            // Показываем скелетон сразу, без задержки
            
            // Используем requestAnimationFrame для показа скелетона в следующем кадре
            requestAnimationFrame(() => {
                // Очищаем скелет перед рендерингом реальных дат
                calendarGrid.innerHTML = '';
                
                const firstDayOfMonth = new Date(currentYear, currentMonth, 1).getDay();
                const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

                calendarMonthDisplay.textContent = `${new Date(currentYear, currentMonth).toLocaleString('ru-RU', { month: 'long' })} ${currentYear}`;

                // Days of week
                const daysOfWeek = ['ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'СБ', 'ВС'];
                daysOfWeek.forEach(day => {
                    const dayElement = document.createElement('div');
                    dayElement.className = 'calendar-day';
                    dayElement.textContent = day;
                    calendarGrid.appendChild(dayElement);
                });

                // Adjust first day to be Monday (0 for Sunday, 1 for Monday, etc.)
                let startDay = firstDayOfMonth === 0 ? 6 : firstDayOfMonth - 1;

                // Add empty divs for days before the 1st
                for (let i = 0; i < startDay; i++) {
                    const emptyDate = document.createElement('div');
                    emptyDate.className = 'calendar-date other-month';
                    const prevMonthDays = new Date(currentYear, currentMonth, 0).getDate();
                    emptyDate.textContent = prevMonthDays - startDay + i + 1;
                    calendarGrid.appendChild(emptyDate);
                }

                // Add days of the current month
                for (let i = 1; i <= daysInMonth; i++) {
                    const dateElement = document.createElement('div');
                    const cellDate = new Date(currentYear, currentMonth, i);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const isPastDate = cellDate < today;
                
                    dateElement.className = 'calendar-date';
                    dateElement.textContent = i;
                    dateElement.dataset.date = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${i.toString().padStart(2, '0')}`;
                    
                    // Проверяем, нужно ли заблокировать дату
                    const dateString = dateElement.dataset.date;
                    const isBeforeNearest = isDateBeforeNearestAvailable(dateString);
                    const shouldDisable = isPastDate || isBeforeNearest;
                    
                    
                    if (shouldDisable) {
                        dateElement.classList.add('disabled');
                        dateElement.style.opacity = '0.3';
                        dateElement.style.cursor = 'not-allowed';
                    } else {
                        // Check availability for non-disabled dates
                        checkDateAvailability(dateString).then(hasSlots => {
                            if (!hasSlots) {
                                dateElement.classList.add('no-slots');
                            }
                        });
                        
                        // НЕ выделяем сегодняшнюю дату автоматически - это будет сделано после загрузки данных о доступности
                        // const hasSelectedDate = document.querySelector('.calendar-date.selected');
                        // if (i === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear() && !hasSelectedDate) {
                        //     dateElement.classList.add('selected');
                        // }

                        dateElement.addEventListener('click', function() {
                            // Don't allow clicking on dates without slots
                            if (this.classList.contains('no-slots')) {
                                return;
                            }
                            
                            selectDate(this, dateString);
                            
                            // Загружаем слоты новым способом с AbortController
                            const abortController = new AbortController();
                            loadSlotsSafe(dateString, { signal: abortController.signal }).catch(error => {
                            });
                        });
                    }
                    
                    calendarGrid.appendChild(dateElement);
                }
                
                // НЕ устанавливаем дефолтную дату здесь - это делается в инициализации
            }); // Показываем скелетон сразу через requestAnimationFrame
        }

        function setDefaultSelections() {
            
            // Сначала убираем все выделения
            document.querySelectorAll('.duration-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelectorAll('.trainer-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            // Выбираем 60 минут по умолчанию
            const duration60 = document.querySelector('.duration-option[data-duration="60"]');
            if (duration60) {
                duration60.classList.add('selected');
            } else {
            }

            // Выбираем "с тренером" по умолчанию
            const withTrainer = document.querySelector('.trainer-btn[data-trainer="with"]');
            if (withTrainer) {
                withTrainer.classList.add('selected');
            } else {
            }

            // Обновляем цену тренера для выбранной услуги
            updateTrainerPrice();
            
            // НЕ устанавливаем дату здесь - она будет установлена после загрузки данных о доступности
        }

        // Установить дефолтную дату (ближайшую доступную)
        function setDefaultDate() {
            return new Promise((resolve) => {
            sendLogToServer('SET_DEFAULT_DATE', 'Вызов setDefaultDate', {
                stack: new Error().stack.split('\n').slice(0, 5)
            });
            const selectedLocation = getSelectedLocation();
            const selectedDuration = getSelectedDuration();
            const cacheKey = `${selectedLocation}_${selectedDuration}`;
            
            sendLogToServer('SET_DEFAULT_DATE', `Начинаем установку дефолтной даты для ${cacheKey}`);
            
            // АГРЕССИВНОЕ ожидание загрузки данных о доступности для мобилок
            const waitForAvailabilityData = () => {
                return new Promise((availabilityResolve) => {
                    let attempts = 0;
                    const maxAttempts = 50; // 5 секунд максимум
                    
                    const checkAvailability = () => {
                        attempts++;
                        
                        // Проверяем, что календарь отрендерен и есть данные о доступности
                        const calendarDates = document.querySelectorAll('.calendar-date:not(.disabled)');
                        const hasAvailabilityData = calendarDates.length > 0;
                        
                        // Дополнительная проверка - есть ли данные в кэше
                        const selectedLocation = getSelectedLocation();
                        const selectedDuration = getSelectedDuration();
                        const cacheKey = `${selectedLocation}_${selectedDuration}`;
                        const hasCacheData = nearestAvailableDates.has(cacheKey);
                        
                        
                        if (hasAvailabilityData && hasCacheData) {
                            availabilityResolve();
                        } else if (attempts >= maxAttempts) {
                            availabilityResolve();
                        } else {
                            setTimeout(checkAvailability, 100);
                        }
                    };
                    checkAvailability();
                });
            };
            
            waitForAvailabilityData().then(() => {
                // ДОПОЛНИТЕЛЬНАЯ задержка для мобильных устройств
                setTimeout(() => {
                    let defaultDate = null;
            
            // Если есть данные о ближайших датах, используем их
            if (nearestAvailableDates.has(cacheKey)) {
                const nearestData = nearestAvailableDates.get(cacheKey);
                
                if (nearestData && nearestData.data && nearestData.data.seance_date) {
                    const nearestDateStr = nearestData.data.seance_date.split('T')[0];
                    defaultDate = nearestDateStr;
                } else {
                }
            } else {
                // Fallback на сегодняшнюю дату, если кэш пуст
                const today = new Date();
                defaultDate = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;
            }
            
            if (!defaultDate) {
                resolve();
                return;
            }
            
            // Находим и выделяем элемент календаря
            const dateElement = document.querySelector(`.calendar-date[data-date="${defaultDate}"]`);
            
            if (dateElement) {
                
                if (!dateElement.classList.contains('disabled')) {
                    // Убираем выделение с других дат
                    selectDate(dateElement, defaultDate);
                    resolve();
                } else {
                    
                    // Ищем следующую доступную дату
                    const allDates = Array.from(document.querySelectorAll('.calendar-date:not(.disabled)'));
                    const sortedDates = allDates
                        .map(el => ({ element: el, date: el.dataset.date }))
                        .filter(item => item.date >= defaultDate)
                        .sort((a, b) => a.date.localeCompare(b.date));
                    
                    if (sortedDates.length > 0) {
                        const nextAvailableDate = sortedDates[0];
                        nextAvailableDate.element.classList.add('selected');
                    } else {
                    }
                    resolve();
                }
            } else {
                resolve();
            }
            
            // Финальная проверка выбранной даты
            const finalSelectedDate = document.querySelector('.calendar-date.selected');
            if (finalSelectedDate) {
                // Дата выбрана
            } else {
                // Дата не выбрана
            }
                }, 500); // Дополнительная задержка для мобилок
            });
            });
        }

        // ===== НОВАЯ АРХИТЕКТУРА: СОБЫТИЙНАЯ СИНХРОНИЗАЦИЯ =====
        
        // Двойной rAF — гарантированно после layout+paint
        const afterPaint = () => new Promise(r =>
            requestAnimationFrame(() => requestAnimationFrame(r))
        );

        // Защита от гонок
        let runId = 0;
        let isInitializing = false;
        const newRun = () => (++runId);
        const isStale = (id) => id !== runId;

        // Хранилище доступности по cacheKey как промис
        const availabilityStore = new Map(); // cacheKey -> Promise<Availability>

        function getAvailability(cacheKey, fetchFn, signal) {
            if (!availabilityStore.has(cacheKey)) {
                const p = fetchFn({ signal }).then(data => {
                    if (!data || !Array.isArray(data.dates)) throw new Error('bad data');
                    return data;
                });
                availabilityStore.set(cacheKey, p);
            }
            return availabilityStore.get(cacheKey);
        }

        // Унифицированный адаптер для слотов - всегда возвращает Slot[]
        async function fetchSlots(dateISO, { signal }) {
            
            const selectedDuration = getSelectedDuration();
            const selectedLocation = getSelectedLocation();
            const serviceId = getServiceIdForLocation(selectedLocation, selectedDuration);
            
            try {
                const response = await fetch(`${API_CONFIG.proxyUrl}/api/slots?companyId=${API_CONFIG.companyId}&staffId=${API_CONFIG.locations[selectedLocation].staffId}&serviceId=${serviceId}&date=${dateISO}`, {
                    signal
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const json = await response.json();
                
                // Адаптер: на переходный период поддерживаем оба формата
                const slots = Array.isArray(json) ? json : json.data;
                
                return slots;
            } catch (error) {
                throw error;
            }
        }

        // Безопасный загрузчик слотов с отменой (использует унифицированный адаптер)
        async function loadSlotsSafe(dateISO, { signal }) {
            
            try {
                const slots = await fetchSlots(dateISO, { signal });
                
                // Рендерим слоты времени
                renderTimeSlots(slots);
                
                return slots;
            } catch (error) {
                throw error; // Пробрасываем ошибку дальше
            }
        }

        // Рендер слотов времени
        function renderTimeSlots(slots) {
            
            const timeSlots = document.querySelector('.time-slots-grid');
            if (!timeSlots) return;
            
            if (!slots || !Array.isArray(slots) || slots.length === 0) {
                timeSlots.innerHTML = `
                    <div class="form-error">
                        <div class="form-error-icon">⚠️</div>
                        <div class="form-error-title">Нет доступных слотов</div>
                        <div class="form-error-description">Попробуйте выбрать другую дату</div>
                    </div>
                `;
                return;
            }
            
            timeSlots.innerHTML = slots.map(slot => `
                <div class="time-slot" data-time="${slot.time}">
                    ${slot.time}
                </div>
            `).join('');
            
            // Добавляем обработчики клика
            timeSlots.querySelectorAll('.time-slot').forEach(slot => {
                slot.addEventListener('click', function() {
                    document.querySelectorAll('.time-slot').forEach(s => s.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
        }

        // Ожидание DOM элемента с таймаутом
        function waitFor(selector, { root = document, timeout = 5000 } = {}) {
            return new Promise((resolve, reject) => {
                const found = root.querySelector(selector);
                if (found) return resolve(found);

                const obs = new MutationObserver(() => {
                    const el = root.querySelector(selector);
                    if (el) { obs.disconnect(); resolve(el); }
                });
                obs.observe(root, { childList: true, subtree: true });

                const t = setTimeout(() => {
                    obs.disconnect();
                    resolve(null); // не reject — UI должен деградировать мягко
                }, timeout);
            });
        }

        // Централизованная функция для выбора даты
        function selectDate(dateElement, dateString = null) {
            
            // КРИТИЧНО: Убираем ВСЕ выделения с ВСЕХ дат
            document.querySelectorAll('.calendar-date').forEach(d => {
                d.classList.remove('selected');
            });
            
            // Выделяем только выбранную дату
            dateElement.classList.add('selected');
            
            
            // Проверяем, что только одна дата выбрана
            const selectedDates = document.querySelectorAll('.calendar-date.selected');
            if (selectedDates.length > 1) {
                // Принудительно исправляем
                selectedDates.forEach((d, index) => {
                    if (index > 0) {
                        d.classList.remove('selected');
                    }
                });
            }
        }

        // ===== НОВЫЙ ПОТОК ИНИЦИАЛИЗАЦИИ =====
        
        // Функция получения доступности из API
        async function fetchAvailability({ signal }) {
            
            const selectedDuration = getSelectedDuration();
            const selectedLocation = getSelectedLocation();
            const serviceId = getServiceIdForLocation(selectedLocation, selectedDuration);
            
            try {
                const response = await fetch(`https://wakeme-booking-api-production.up.railway.app/api/availability`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        service_id: serviceId,
                        start_date: new Date().toISOString().split('T')[0],
                        end_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
                    }),
                    signal
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                
                // Преобразуем в нужный формат
                const dates = (data.available_dates || []).map(date => ({
                    dateISO: date,
                    hasFreeSlots: true, // Пока считаем доступными, реальная проверка будет в checkDateAvailability
                    slotsCount: 0 // Будет заполнено при загрузке слотов
                }));
                
                
                
                return {
                    dates
                };
            } catch (error) {
                throw error; // Пробрасываем ошибку дальше
            }
        }

        // Рендер календаря из данных (детерминированный)
        function renderCalendarFromData(availability) {
            
            const calendarGrid = document.querySelector('.calendar-grid');
            const calendarMonthDisplay = document.querySelector('.calendar-month');
            
            // Очищаем календарь и создаем заново
            calendarGrid.innerHTML = '';
            
            const firstDayOfMonth = new Date(currentYear, currentMonth, 1).getDay();
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
            
            calendarMonthDisplay.textContent = `${new Date(currentYear, currentMonth).toLocaleString('ru-RU', { month: 'long' })} ${currentYear}`;
            
            // Создаем пустые ячейки для начала месяца
            for (let i = 0; i < firstDayOfMonth; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.className = 'calendar-date empty';
                calendarGrid.appendChild(emptyCell);
            }
            
            // Создаем даты со скелетом СРАЗУ
            const dateElements = [];
            for (let i = 1; i <= daysInMonth; i++) {
                const dateElement = document.createElement('div');
                dateElement.className = 'calendar-date skeleton';
                // НЕ добавляем textContent - только скелет
                dateElements.push(dateElement);
                calendarGrid.appendChild(dateElement);
            }
            
            
            // НОВЫЙ ПОДХОД: Создаем все промисы сразу, без пакетной обработки
            const availabilityPromises = [];
            const availableDates = [];
            
            // Проходим по всем датам и создаем промисы
            for (let i = 0; i < dateElements.length; i++) {
                const dateElement = dateElements[i];
                
                // Устанавливаем правильную дату для элемента
                const date = new Date(currentYear, currentMonth, i + 1);
                const dateString = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${(i + 1).toString().padStart(2, '0')}`;
                dateElement.dataset.date = dateString;
                
                // Проверяем доступность из данных API
                const isAvailable = availability.dates.some(d => d.dateISO === dateString && d.hasFreeSlots);
                
                
                if (!isAvailable) {
                    // Дата недоступна - убираем скелет и блокируем
                    dateElement.classList.remove('skeleton');
                    dateElement.classList.add('disabled');
                    dateElement.textContent = i + 1; // Добавляем номер даты
                } else {
                    // Дата доступна - проверяем реальную доступность слотов
                    const availabilityPromise = checkDateAvailability(dateString).then(hasSlots => {
                        // Убираем скелет
                        dateElement.classList.remove('skeleton');
                        dateElement.textContent = i + 1; // Добавляем номер даты
                        
                        if (!hasSlots) {
                            dateElement.classList.add('no-slots');
                            return { dateString, hasSlots: false };
                        } else {
                            return { dateString, hasSlots: true };
                        }
                    }).catch(error => {
                        // Убираем скелет и блокируем дату
                        dateElement.classList.remove('skeleton');
                        dateElement.classList.add('no-slots');
                        dateElement.textContent = i + 1; // Добавляем номер даты
                        return { dateString, hasSlots: false };
                    });
                    
                    availabilityPromises.push(availabilityPromise);
                }
            }
            
            
            // Ждем завершения всех проверок доступности + добавляем задержку
            if (availabilityPromises.length > 0) {
                Promise.all(availabilityPromises).then(async results => {
                    
                    // Ждем завершения отрисовки
                    await afterPaint();
                    
                    // Находим ближайшую доступную дату
                    const availableDates = results.filter(r => r && r.hasSlots).sort((a, b) => a.dateString.localeCompare(b.dateString));
                    
                    
                    if (availableDates.length > 0) {
                        const nearestDate = availableDates[0].dateString;
                        
                        // Выделяем ближайшую доступную дату
                        const nearestDateElement = document.querySelector(`.calendar-date[data-date="${nearestDate}"]`);
                        if (nearestDateElement && !nearestDateElement.classList.contains('skeleton')) {
                            // Выбираем дату
                            selectDate(nearestDateElement, nearestDate);
                            
                            // Загружаем слоты новым способом с AbortController
                            const abortController = new AbortController();
                            loadSlotsSafe(nearestDate, { signal: abortController.signal }).catch(error => {
                            });
                        } else {
                        }
                    } else {
                    }
                });
            } else {
            }
            
            // Добавляем обработчики клика для всех дат
            dateElements.forEach(dateElement => {
                // Убираем старые обработчики
                dateElement.removeEventListener('click', dateElement._clickHandler);
                
                // Добавляем новый обработчик
                dateElement._clickHandler = () => {
                    if (dateElement.classList.contains('disabled') || 
                        dateElement.classList.contains('no-slots') || 
                        dateElement.classList.contains('skeleton')) return;
                    
                    const dateString = dateElement.dataset.date;
                    selectDate(dateElement, dateString);
                    
                    // Загружаем слоты новым способом с AbortController
                    const abortController = new AbortController();
                    loadSlotsSafe(dateString, { signal: abortController.signal }).catch(error => {
                    });
                };
                
                dateElement.addEventListener('click', dateElement._clickHandler);
            });
        }

        // Выделение даты (чистая функция)
        function highlightDate(dateISO) {
            
            const dateElement = document.querySelector(`.calendar-date[data-date="${dateISO}"]`);
            if (dateElement && !dateElement.classList.contains('disabled')) {
                selectDate(dateElement, dateISO);
            }
        }

        // Основная функция инициализации с событийной синхронизацией
        async function initBooking({ cacheKey, fetchAvailability, renderCalendar, highlightDate, fetchSlots, savedDate }) {
            // Предотвращаем множественные инициализации
            if (isInitializing) {
                return;
            }
            
            isInitializing = true;
            const myRun = newRun();
            const controller = new AbortController();
            const { signal } = controller;


            try {
                // 1) Тянем данные. Никаких setTimeout.
                const availabilityPromise = getAvailability(cacheKey, fetchAvailability, signal);

                // 2) Ждем данные и первый paint календаря
                const [availability] = await Promise.all([
                    availabilityPromise,
                    waitFor('.calendar-grid')
                ]);
                
                if (isStale(myRun)) {
                    return;
                }


                // 3) Рендерим календарь строго из данных, не из DOM
                renderCalendarFromData(availability);
                await afterPaint();
                if (isStale(myRun)) return;

                // 4) НЕ ВЫБИРАЕМ ДАТУ ЗДЕСЬ - это будет сделано в renderCalendarFromData

                // Возвращаем функцию отмены
                return () => {
                    controller.abort();
                };

            } catch (error) {
                if (error.name === 'AbortError') {
                } else {
                }
            } finally {
                // Сбрасываем флаг инициализации
                isInitializing = false;
            }
        }

        // Глобальная переменная для отмены
        let cancelCurrent = null;

        // Обработчик смены услуги/локации без гонок
        async function onServiceOrLocationChange({ cacheKey, ...deps }) {
            
            // Сохраняем текущую выбранную дату
            const currentSelectedDate = document.querySelector('.calendar-date.selected');
            const savedDate = currentSelectedDate ? currentSelectedDate.dataset.date : null;
            
            // СРАЗУ показываем скелет для календаря при смене
            const calendarGrid = document.querySelector('.calendar-grid');
            if (calendarGrid) {
                const dateElements = calendarGrid.querySelectorAll('.calendar-date:not(.empty)');
                dateElements.forEach(dateElement => {
                    dateElement.classList.add('skeleton');
                    dateElement.classList.remove('selected', 'disabled', 'no-slots');
                    dateElement.textContent = ''; // Убираем текст для скелета
                });
            }
            
            // Также показываем скелет для времени при смене
            const timeSlotsContainer = document.querySelector('.time-slots-grid');
            if (timeSlotsContainer) {
                timeSlotsContainer.innerHTML = '';
                
                // Создаем 3-4 скелета для времени
                for (let i = 0; i < 4; i++) {
                    const skeletonSlot = document.createElement('div');
                    skeletonSlot.className = 'time-slot skeleton';
                    timeSlotsContainer.appendChild(skeletonSlot);
                }
            }
            
            if (cancelCurrent) {
                cancelCurrent(); // мгновенно гасим старые запросы
            }
            
            cancelCurrent = await initBooking({ cacheKey, ...deps, savedDate });
        }

        // afterPaint уже определен выше

        // Отправка логов на сервер
        function sendLogToServer(level, message, data = {}) {
            const logData = {
                level: level,
                message: message,
                data: data,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                url: window.location.href
            };
            
            // Отправляем на сервер
            fetch('https://wakeme-booking-api-production.up.railway.app/api/logs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(logData)
            }).catch(err => {
            });
            
            // Также выводим в консоль
        }


        // Initialize
        // НОВАЯ АРХИТЕКТУРА: Инициализация с событийной синхронизацией
        
        // Скелет будет показан в renderCalendarFromData
        // Но сразу показываем скелет времени при инициализации
        const timeSlotsContainer = document.querySelector('.time-slots-grid');
        if (timeSlotsContainer) {
            timeSlotsContainer.innerHTML = '';
            
            // Создаем 4-5 скелетов для времени
            for (let i = 0; i < 5; i++) {
                const skeletonSlot = document.createElement('div');
                skeletonSlot.className = 'time-slot skeleton';
                timeSlotsContainer.appendChild(skeletonSlot);
            }
        }
        
        // Защита от ошибок внешних скриптов Tilda
        window.addEventListener('error', function(e) {
            if (e.message.includes('initScrollBooster') || e.message.includes('children')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Устанавливаем дефолтные значения
        setDefaultSelections();
        
        // Инициализируем с новой архитектурой
        const selectedDuration = getSelectedDuration();
        const selectedLocation = getSelectedLocation();
        const cacheKey = `${selectedLocation}_${selectedDuration}`;
        
        
        initBooking({
            cacheKey,
            fetchAvailability,
            renderCalendar: renderCalendarFromData,
            highlightDate,
            fetchSlots: loadSlotsSafe
        }).then((cancelFn) => {
            if (cancelFn) {
                cancelCurrent = cancelFn;
            }
        }).catch(error => {
            
            // Показываем ошибку пользователю
            const calendarGrid = document.querySelector('.calendar-grid');
            if (calendarGrid) {
                calendarGrid.innerHTML = `
                    <div class="form-error">
                        <div class="form-error-icon">⚠️</div>
                        <div class="form-error-title">Ошибка загрузки данных</div>
                        <div class="form-error-description">Не удалось подключиться к серверу. Проверьте подключение к интернету.</div>
                    </div>
                `;
            }
            
            const timeSlots = document.querySelector('.time-slots-grid');
            if (timeSlots) {
                timeSlots.innerHTML = `
                    <div class="form-error">
                        <div class="form-error-icon">⚠️</div>
                        <div class="form-error-title">Нет доступных слотов</div>
                        <div class="form-error-description">Попробуйте обновить страницу</div>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>