<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WakeMe - Онлайн запись</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Unbounded:wght@200;300;400;500;600;700;800;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            margin: 0;
            padding: 0;
            outline: none;
            border: none;
        }

        body {
            font-family: 'Unbounded', sans-serif;
            background: white;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            outline: none;
            border: none;
            overflow-x: hidden; /* предотвращаем горизонтальный скролл на мобайле */
        }

        /* Phone UI fallback */
        .phone-row { display: flex; gap: 8px; align-items: center; }
        .phone-code-select { height: 42px; border: 1px solid #e9ecef; border-radius: 8px; padding: 0 8px; background: #fff; }
        .phone-code-badge { min-width: 70px; height: 42px; display: flex; align-items: center; justify-content: center; background: #f1f3f5; border-radius: 8px; font-size: 14px; color: #333; }

        /* Custom phone control */
        .phone-input { position: relative; display: flex; align-items: center; gap: 0; width: 100%; height: 48px; background: #fff; border: 1px solid #e9ecef; border-radius: 8px; overflow: visible; }
        .phone-select { display: flex; align-items: center; gap: 6px; padding: 0 12px; cursor: pointer; user-select: none; background: #fff; height: 100%; border-right: 1px solid #e9ecef; }
        .phone-select-code { font-weight: 500; color: #2c2c2c; }
        .phone-caret { width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 6px solid #999; }
        .phone-dropdown { position: absolute; top: 50px; left: 0; right: 0; max-height: 260px; overflow: auto; background: #fff; border: 1px solid #e9ecef; border-radius: 10px; box-shadow: 0 8px 20px rgba(0,0,0,0.08); z-index: 1000; display: none; }
        .phone-dropdown.show { display: block; }
        .phone-item { padding: 10px 12px; display: flex; align-items: center; justify-content: space-between; font-size: 14px; cursor: pointer; }
        .phone-item:hover { background: #f8f9fa; }
        .phone-input .form-input { border: none !important; height: 100%; margin: 0; }
        .phone-select:hover { background: #f8f9fa; }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .location-section {
            grid-column: 1;
        }

        .calendar-section {
            grid-column: 2;
        }

        .service-section {
            grid-column: 3;
        }

        .time-section {
            grid-column: 4;
            padding-top: 10px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s ease;
        }


        .location-options {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .location-btn {
            padding: 12px 16px;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .location-btn:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .location-btn.selected {
            background: #64D7F2;
            color: white;
        }

        .location-btn.selected .location-name {
            color: white;
        }

        .location-btn.selected .feature-item {
            color: rgba(255, 255, 255, 0.9);
        }

        .location-name {
            font-family: 'Unbounded', sans-serif;
            font-size: 12px;
            font-weight: 500;
            color: #2c2c2c;
            margin-bottom: 4px;
        }

        .location-address {
            font-family: 'Unbounded', sans-serif;
            font-size: 11px;
            font-weight: 300;
            color: #666;
        }

        .location-features {
            margin-top: 8px;
        }

        .feature-item {
            font-family: 'Unbounded', sans-serif;
            font-size: 9px;
            font-weight: 300;
            color: #666;
            line-height: 1.4;
            margin-bottom: 2px;
        }

        .feature-item:last-child {
            margin-bottom: 0;
        }

        .feature-item em {
            font-style: italic;
        }

        .location-map {
            width: 100%;
            height: 200px;
            background: #f8f9fa;
            border-radius: 12px;
            margin-top: 16px;
            position: relative;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }

        .map-pin {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: #ff4444;
            border-radius: 50% 50% 50% 0;
            transform: translate(-50%, -50%) rotate(-45deg);
        }

        .map-pin::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        .map-fullscreen {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            color: #666;
        }

        .duration-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .duration-option {
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            background: white;
        }

        .duration-option:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .duration-option.selected {
            background: #64D7F2;
            color: white;
        }

        .duration-option.selected .duration-price {
            color: rgba(255, 255, 255, 0.9);
        }

        .duration-option.selected .duration-time {
            color: white;
        }

        .duration-time {
            font-size: 14px;
            font-weight: 500;
            color: #2c2c2c;
            margin-bottom: 2px;
        }

        .duration-price {
            font-size: 12px;
            font-weight: 500;
            color: #999;
        }

        .section-divider {
            height: 1px;
            background: #e9ecef;
            margin: 16px 0;
        }

        .trainer-options {
            display: flex;
            flex-direction: row;
            gap: 8px;
            width: 100%;
        }

        .trainer-btn {
            font-family: 'Unbounded', sans-serif;
            padding: 12px 16px;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 11px;
            font-weight: 400;
            margin-bottom: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            width: 100%;
            min-height: 60px;
            color: #2c2c2c; /* заголовок чёрный в неактивном состоянии */
        }

        .trainer-btn span { white-space: nowrap; }

        .trainer-btn:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .trainer-btn.selected {
            background: #64D7F2;
            color: white;
        }

        .trainer-price {
            font-size: 12px;
            font-weight: 500;
            color: #999;
            margin-top: 2px;
        }

        .trainer-btn.selected .trainer-price {
            color: rgba(255, 255, 255, 0.8);
        }


        .booking-form {
            background: #f8f9fa;
            border-radius: 16px;
            padding: 30px;
            margin-top: -20px;
        }

        .form-header {
            text-align: left;
            margin-bottom: 20px;
        }

        .form-title {
            font-family: 'Unbounded', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .form-description {
            font-family: 'Unbounded', sans-serif;
            font-size: 12px;
            font-weight: 400;
            color: #666;
            margin-bottom: 24px;
        }

        /* Popup Styles */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            padding: 16px; /* небольшое поле, чтобы модалка не упиралась в края */
        }

        .popup-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .popup {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 420px;
            width: 100%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            position: relative;
        }

        .popup-overlay.show .popup {
            transform: scale(1);
        }

        .popup-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }

        .popup-icon.success {
            background: #d4edda;
            color: #155724;
        }

        .popup-icon.error {
            background: #f8d7da;
            color: #721c24;
        }

        .popup-title {
            font-family: 'Unbounded', sans-serif;
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .popup-message {
            font-family: 'Unbounded', sans-serif;
            font-size: 14px;
            font-weight: 400;
            color: #666;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .popup-button {
            font-family: 'Unbounded', sans-serif;
            background: #64D7F2;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .popup-button:hover {
            background: #4BC5E8;
        }
        .popup-actions { display: flex; gap: 8px; margin-top: 8px; }
        .popup-button.outline { background: #fff; color: #333; border: 1px solid #e9ecef; }
        .popup-button.whatsapp { background: #25D366; }
        .popup-button.whatsapp:hover { background: #1ebe57; }
        .btn-icon { display: inline-flex; width: 16px; height: 16px; margin-right: 8px; align-items: center; justify-content: center; }
        .popup-close { position: absolute; top: 10px; right: 10px; width: 28px; height: 28px; border-radius: 50%; background: #f1f3f5; border: 1px solid #e9ecef; cursor: pointer; color: #666; display: flex; align-items: center; justify-content: center; font-size: 16px; }
        .popup-close:hover { background: #eceff1; }

        .booking-form form {
            display: flex;
            gap: 8px;
            align-items: center;
            width: 100%;
            align-items: stretch;
        }

        .form-group {
            flex: 0.8;
            margin-bottom: 0;
            display: flex;
            align-items: center;
        }

        .booking-btn {
            flex-shrink: 0;
            width: 250px;
            height: 48px;
            padding: 0 32px;
            margin: 0;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }



        .form-group {
            margin-bottom: 20px;
        }


        .form-input {
            font-family: 'Unbounded', sans-serif;
            width: 100%;
            padding: 0 16px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 400;
            transition: all 0.2s;
            background: white;
            height: 48px;
            margin: 0;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            background: white;
        }

        .form-input::placeholder {
            font-size: 12px;
            font-weight: 300;
            color: #999;
        }

        .booking-btn {
            font-family: 'Unbounded', sans-serif;
            background: #64D7F2;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 400;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .booking-btn:hover {
            background: #4BC5E8;
        }

        .booking-btn:focus {
            outline: none;
        }

        /* Убираем обводки со всех кнопок при фокусе */
        button:focus {
            outline: none;
        }

        /* Убираем все обводки с input и button */
        input, button {
            border: none !important;
            outline: none !important;
        }

        .booking-form * {
            box-sizing: border-box;
        }

        .booking-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .time-slots-grid-section {
            margin-top: 20px;
        }

        .time-slots-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 16px;
        }

        .time-slot {
            padding: 12px 8px;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
            background: white;
        }

        .time-slot:hover {
            background: rgba(100, 215, 242, 0.05);
        }

        .time-slot.selected {
            background: #64D7F2;
            color: white;
        }

        .time-slot.unavailable {
            background: #f5f5f5;
            color: #ccc;
            cursor: not-allowed;
        }

        /* Skeleton loading animation */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 8px;
        }

        @keyframes skeleton-loading {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }

        .time-slot.skeleton {
            height: 48px;
            margin-bottom: 8px;
        }

        .calendar-date.skeleton {
            height: 32px;
            width: 32px;
            border-radius: 50%;
        }

        /* Плавные переходы для дат календаря */
        .calendar-date {
            transition: all 0.3s ease;
        }

        .calendar-date.skeleton {
            transition: all 0.2s ease;
        }

        .calendar-date:not(.skeleton) {
            transition: all 0.3s ease;
        }

        .total-info {
            background: rgba(100, 215, 242, 0.05);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            text-align: center;
        }

        .total-amount {
            font-size: 24px;
            font-weight: 700;
            color: #64D7F2;
            margin-bottom: 4px;
        }

        .total-details {
            font-size: 14px;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            text-align: center;
            padding: 20px;
            color: #ff4444;
            background: #fff5f5;
            border-radius: 8px;
        }

        .form-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            width: 100%;
            height: 100%;
            min-height: 200px;
        }

        .form-error-icon {
            font-size: 32px;
            margin-bottom: 16px;
            text-align: center;
        }

        .form-error-title {
            font-family: 'Unbounded', sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
        }

        .form-error-description {
            font-family: 'Unbounded', sans-serif;
            font-size: 10px;
            font-weight: 400;
            color: #666;
            text-align: center;
        }

        /* Calendar Styles */

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .calendar-nav {
            background: #f8f9fa;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-nav:hover {
            background: #64D7F2;
            color: white;
        }

        .calendar-month {
            font-size: 14px;
            font-weight: 500;
            color: #2c2c2c;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        .calendar-day {
            text-align: center;
            padding: 6px 2px;
            font-size: 11px;
            color: #999;
            font-weight: 500;
        }

        .calendar-date {
            text-align: center;
            padding: 6px 2px;
            font-size: 12px;
            color: #2c2c2c;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 400;
        }

        .calendar-date:hover {
            background: rgba(100, 215, 242, 0.1);
        }

        .calendar-date.selected {
            background: #64D7F2;
            color: white;
        }

        .calendar-date.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            color: #999;
            background: transparent;
        }

        .calendar-date.disabled:hover {
            background: transparent;
        }

        .calendar-date.no-slots {
            color: #999;
            opacity: 0.5;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .calendar-date.no-slots:hover {
            background: #f5f5f5;
        }

        .calendar-date.other-month {
            color: #999;
            cursor: not-allowed;
            opacity: 0.3;
        }

        .calendar-date.other-month:hover {
            background: transparent;
            transform: none;
        }

        /* Mobile styles */
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .location-section {
                grid-column: 1;
            }

            .calendar-section {
                grid-column: 2;
            }

            .service-section {
                grid-column: 1;
            }

            .time-section {
                grid-column: 2;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 5%;
                max-width: 90%;
            }
            .popup { max-width: 520px; width: 100%; }
            .popup-overlay { padding: 12px; }
            
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
                display: flex; /* на мобайле используем flex для управления порядком */
                flex-direction: column;
            }

            .location-section,
            .calendar-section,
            .service-section,
            .time-section {
                grid-column: 1;
            }

            /* Переупорядочивание блоков на мобайле: сначала услуги, потом календарь */
            .location-section { order: 1; }
            .service-section { order: 2; }
            .calendar-section { order: 3; }
            .time-section { order: 4; }
            
            /* Секция времени теперь работает с реальным API */

            .duration-options {
                grid-template-columns: 1fr 1fr;
            }

            .time-slots-grid {
                grid-template-columns: 1fr 1fr;
            }

            .booking-form form {
                flex-direction: column;
                gap: 0; /* контролируем отступы отдельно */
                align-items: stretch;
            }

            .form-group {
                margin-bottom: 0;
                min-width: auto;
                width: 100%;
            }
            /* Отступ между именем и телефоном — ~в 3 раза меньше (6px) */
            .booking-form .form-group + .form-group { margin-top: 6px; }
            /* Отступ между телефоном и кнопкой — 8px + дополнительным запросом +10px = 18px */
            .booking-form .booking-btn { margin-top: 18px; }

            .booking-btn {
                min-width: auto;
                width: 100%;
                max-width: 300px;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .container {
                padding: 0 2%;
                max-width: 95%;
            }
            
            .duration-options {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Main Content -->
        <div class="main-content">
            <!-- Location Selection -->
            <div class="section location-section">
                <div class="location-options">
                    <button class="location-btn selected" data-location="DUBAI_HARBOUR_MARINA">
                        <div class="location-name">Marina Harbour</div>
                        <div class="location-features">
                            <div class="feature-item">• удобное расположение в центре города</div>
                            <div class="feature-item">• вид на колесо обозрения Ain Dubai, JBR и Address Beach Residences</div>
                            <div class="feature-item">• кристально-голубая вода</div>
                        </div>
                    </button>
                    <button class="location-btn" data-location="DUBAI_CREEK_HARBOUR">
                        <div class="location-name">Creek Harbour</div>
                        <div class="location-features">
                            <div class="feature-item">• локация без сторонних волн</div>
                            <div class="feature-item">• закат с видом на <em>Burj Khalifa</em></div>
                            <div class="feature-item">• нет <em>Jet Ski</em></div>
                        </div>
                    </button>
                </div>
            </div>

            <!-- Calendar Section -->
            <div class="section calendar-section">
                <div class="calendar-header">
                    <button class="calendar-nav" onclick="changeMonth(-1)">‹</button>
                    <div class="calendar-month">Октябрь 2025</div>
                    <button class="calendar-nav" onclick="changeMonth(1)">›</button>
                </div>
                <div class="calendar-grid">
                    <!-- Calendar days and dates will be dynamically generated by JS -->
                </div>
            </div>

            <!-- Service & Trainer Selection -->
            <div class="section service-section">
                <div class="duration-options">
                    <div class="duration-option" data-duration="30">
                        <div class="duration-time">30 мин</div>
                        <div class="duration-price">390 AED</div>
                    </div>
                    <div class="duration-option" data-duration="45">
                        <div class="duration-time">45 мин</div>
                        <div class="duration-price">565 AED</div>
                    </div>
                    <div class="duration-option" data-duration="60">
                        <div class="duration-time">60 мин</div>
                        <div class="duration-price">750 AED</div>
                    </div>
                    <div class="duration-option" data-duration="90">
                        <div class="duration-time">90 мин</div>
                        <div class="duration-price">1 125 AED</div>
                    </div>
                    <div class="duration-option" data-duration="120">
                        <div class="duration-time">120 мин</div>
                        <div class="duration-price">1 500 AED</div>
                    </div>
                </div>
                
                <div class="section-divider"></div>
                
                <div class="trainer-options">
                    <button class="trainer-btn" data-trainer="with">
                        <span>С тренером</span>
                        <span class="trainer-price" id="trainerPrice">+COACH</span>
                    </button>
                    <button class="trainer-btn" data-trainer="without">
                        <span>Без тренера</span>
                    </button>
                </div>
            </div>

            <!-- Time Selection -->
            <div class="section time-section">
                <div class="time-slots-grid" id="timeSlots">
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                    <div class="time-slot skeleton"></div>
                </div>
            </div>
        </div>


        <!-- Booking Form -->
        <div class="booking-form">
            <div class="form-header">
                <div class="form-title">Заполните форму</div>
                <div class="form-description">Мы свяжемся с вами в WhatsApp для подтверждения даты</div>
            </div>
            <form id="bookingForm">
                <div class="form-group">
                    <input type="text" id="clientName" class="form-input" required placeholder="Имя">
                </div>
                
                <div class="form-group">
                    <input type="tel" id="clientPhone" class="form-input" required placeholder="Телефон">
                </div>
                
                <button type="submit" class="booking-btn" id="bookingBtn">
                    Забронировать
                </button>
            </form>
        </div>
    </div>

    <!-- Popup -->
    <div class="popup-overlay" id="popupOverlay">
        <div class="popup">
            <div class="popup-icon" id="popupIcon"></div>
            <div class="popup-title" id="popupTitle"></div>
            <div class="popup-message" id="popupMessage"></div>
            <button class="popup-button" id="popupButton">Продолжить</button>
        </div>
    </div>

    <!-- Payment choice Popup -->
    <div class="popup-overlay" id="paymentChoiceOverlay">
        <div class="popup">
            <button class="popup-close" id="paymentCloseBtn" aria-label="Закрыть">×</button>
            <div class="popup-title">Выберите способ оплаты</div>
            <div class="popup-message">Оплатите сейчас картой на сайте или свяжитесь с менеджером в WhatsApp.</div>
            <div class="popup-actions">
                <button class="popup-button" id="payCardBtn">
                    <span class="btn-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M3 5h18a2 2 0 0 1 2 2v2H1V7a2 2 0 0 1 2-2zm-2 8h22v4a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2v-4zm4 3h4v-2H5v2z"/></svg>
                    </span>
                    Оплатить картой на сайте
                </button>
                <button class="popup-button outline whatsapp" id="payLaterBtn">
                    <span class="btn-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M20.52 3.48A11.86 11.86 0 0 0 12.05 0C5.49 0 .22 5.27.22 11.83c0 2.09.55 4.14 1.59 5.94L0 24l6.4-1.67a11.78 11.78 0 0 0 5.64 1.44h.01c6.56 0 11.83-5.27 11.83-11.83a11.8 11.8 0 0 0-3.36-8.46zM12.05 21.1h-.01a9.26 9.26 0 0 1-4.72-1.29l-.34-.2-3.8.99 1.02-3.7-.22-.38a9.25 9.25 0 0 1-1.4-4.89c0-5.1 4.15-9.25 9.26-9.25a9.2 9.2 0 0 1 6.55 2.71 9.22 9.22 0 0 1 2.7 6.54c0 5.1-4.15 9.25-9.25 9.25zm5.1-6.98c-.28-.14-1.66-.82-1.92-.91-.26-.1-.45-.14-.64.14s-.74.91-.91 1.09c-.17.18-.34.2-.62.07-.28-.14-1.17-.43-2.24-1.36-.83-.74-1.39-1.65-1.55-1.93-.16-.28-.02-.43.12-.57.12-.12.28-.31.41-.46.14-.15.18-.26.27-.43.09-.18.05-.32-.02-.46-.07-.14-.64-1.55-.88-2.12-.23-.56-.47-.49-.64-.5l-.54-.01c-.18 0-.46.07-.7.32s-.92.9-.92 2.2 1.13 2.55 1.29 2.73c.16.18 2.22 3.39 5.38 4.75.75.32 1.33.51 1.78.65.75.24 1.42.21 1.96.13.6-.09 1.66-.68 1.9-1.34.24-.66.24-1.23.17-1.34-.07-.11-.26-.18-.54-.32z"/></svg>
                    </span>
                    Оплатить позже с менеджером
                </button>
            </div>
        </div>
    </div>

    <!-- intl-tel-input отключён: используем кастомный селектор кода страны без флагов -->

    <script>
        // API Configuration
        const API_CONFIG = {
            proxyUrl: 'https://wakeme-booking-api-production.up.railway.app',
            companyId: 1252189,
            locations: {
                'DUBAI_HARBOUR_MARINA': {
                    staffId: 2742288,
                    services: {
                        without: {
                            30: 13070888,
                            45: 13070889,
                            60: 13070890,
                            90: 13070891,
                            120: 13070892
                        },
                        with: {
                            30: 13070896,
                            45: 13070899,
                            60: 13070900,
                            90: 13070905,
                            120: 13070908
                        }
                    }
                },
                'DUBAI_CREEK_HARBOUR': {
                    staffId: 2780637,
                    services: {
                        without: {
                            30: 13070912,
                            45: 13070913,
                            60: 13070914,
                            90: 13070915,
                            120: 13070916
                        },
                        with: {
                            30: 13070917,
                            45: 13070918,
                            60: 13070919,
                            90: 13070920,
                            120: 13070921
                        }
                    }
                }
            }
        };

        // Price configuration
        const PRICES = {
            30: { base: 390, withTrainer: 540 },
            45: { base: 565, withTrainer: 790 },
            60: { base: 750, withTrainer: 1050 },
            90: { base: 1125, withTrainer: 1575 },
            120: { base: 1500, withTrainer: 2100 }
        };

        // Telegram Bot Configuration (используется только на серверном вебхуке после оплаты)
        const TELEGRAM_BOT_TOKEN = 'YOUR_BOT_TOKEN_HERE';
        const TELEGRAM_CHAT_ID = 'YOUR_CHAT_ID_HERE';

        // Кэш для хранения ближайших доступных дат
        const availableDatesCache = new Map();
        
        // Глобальная переменная для хранения ближайших доступных дат
        let nearestAvailableDates = new Map();
        
        // Переменная для сохранения даты при смене услуги/локации
        let savedDate = null;

        // Получить ближайшие доступные слоты для локации
        async function getNearestAvailableSlots(locationKey, serviceId) {
            const cacheKey = `${locationKey}_${serviceId}`;
            
            // Проверяем кэш
            if (availableDatesCache.has(cacheKey)) {
                return availableDatesCache.get(cacheKey);
            }

            try {
                const staffId = API_CONFIG.locations[locationKey].staffId;
                const url = `${API_CONFIG.proxyUrl}/api/nearest-slots?companyId=${API_CONFIG.companyId}&staffId=${staffId}&serviceId=${serviceId}`;
                
                
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Кэшируем результат
                    availableDatesCache.set(cacheKey, data);
                    return data;
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                return null;
            }
        }

        // Проверить, нужно ли заблокировать дату (до ближайшего доступного слота)
        function isDateBeforeNearestAvailable(dateString) {
            const selectedLocation = getSelectedLocation();
            const selectedDuration = getSelectedDuration();
            const cacheKey = `${selectedLocation}_${selectedDuration}`;
            
            
            if (!nearestAvailableDates.has(cacheKey)) {
                return false; // Если нет данных, не блокируем
            }
            
            const nearestData = nearestAvailableDates.get(cacheKey);
            if (!nearestData || !nearestData.data || !nearestData.data.seance_date) {
                return false;
            }
            
            // Извлекаем только дату из ISO строки (убираем время)
            const nearestDateStr = nearestData.data.seance_date.split('T')[0];
            const checkDateStr = dateString;
            
            
            // Блокируем даты до ближайшего доступного слота (сравниваем строки дат)
            const shouldBlock = checkDateStr < nearestDateStr;
            
            return shouldBlock;
        }

        // Загрузить ближайшие доступные даты для всех локаций и услуг
        async function loadNearestAvailableDates() {
            // Загружаем для варианта "с тренером" как более ограничивающего
            const durations = Object.keys(PRICES);
            for (const locationKey of Object.keys(API_CONFIG.locations)) {
                for (const duration of durations) {
                    const serviceId = getServiceIdForLocation(locationKey, Number(duration), 'with');
                    const cacheKey = `${locationKey}_${duration}`;
                    try {
                        const data = await getNearestAvailableSlots(locationKey, serviceId);
                        if (data && data.success) {
                            nearestAvailableDates.set(cacheKey, data);
                        }
                    } catch (error) {}
                }
            }
        }

        // Load time slots from API
        async function loadTimeSlots() {
            const timeSlots = document.querySelector('.time-section .time-slots-grid');
            if (!timeSlots) return;
            
            // Показываем скелет анимацию
            timeSlots.innerHTML = `
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
                <div class="time-slot skeleton"></div>
            `;
            
            // Показываем скелетон сразу, без задержки
            requestAnimationFrame(async () => {
                try {
                    const selectedDate = getCurrentDate();
                    
                    // Используем унифицированный адаптер
                    const slots = await fetchSlots(selectedDate, { signal: new AbortController().signal });
                    renderTimeSlots(slots);
                    
                } catch (error) {
                    const timeSlots = document.querySelector('.time-section .time-slots-grid');
                    if (timeSlots) {
                        timeSlots.innerHTML = `<div class="error">Ошибка загрузки слотов: ${error.message}</div>`;
                    }
                }
            }); // Показываем скелетон сразу через requestAnimationFrame
        }

        // Display time slots
        // displayTimeSlots удалена - теперь везде используется renderTimeSlots с унифицированным контрактом Slot[]

        // Helper functions
        function getSelectedDuration() {
            const selectedDuration = document.querySelector('.duration-option.selected');
            return parseInt(selectedDuration.dataset.duration);
        }

        function getSelectedLocation() {
            const selectedLocationBtn = document.querySelector('.location-btn.selected');
            return selectedLocationBtn.dataset.location;
        }

        function getServiceIdForLocation(locationKey, durationId, trainer) {
            const trainerKey = trainer === 'with' ? 'with' : 'without';
            return API_CONFIG.locations[locationKey].services[trainerKey][durationId];
        }

        function getStaffIdForLocation(locationKey) {
            return API_CONFIG.locations[locationKey].staffId;
        }

        // Calculate total price
        function calculateTotalPrice() {
            const duration = getSelectedDuration();
            const trainer = getSelectedTrainer();
            
            if (!PRICES[duration]) {
                return 0;
            }
            
            let price;
            if (trainer === 'with') {
                price = PRICES[duration].withTrainer;
            } else {
                price = PRICES[duration].base;
            }
            
            // Форматируем число с пробелами для тысяч
            return price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
        }

        // Update trainer price display
        function updateTrainerPrice() {
            const duration = getSelectedDuration();
            const trainerPriceElement = document.getElementById('trainerPrice');
            
            if (trainerPriceElement && PRICES[duration]) {
                const basePrice = PRICES[duration].base;
                const withTrainerPrice = PRICES[duration].withTrainer;
                const difference = withTrainerPrice - basePrice;
                
                // Форматируем число с пробелами для тысяч
                const formattedDifference = difference.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
                trainerPriceElement.textContent = `+${formattedDifference} AED`;
            }
        }

        // Popup functions
        function showPopup(type, title, message) {
            const overlay = document.getElementById('popupOverlay');
            const icon = document.getElementById('popupIcon');
            const titleEl = document.getElementById('popupTitle');
            const messageEl = document.getElementById('popupMessage');
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // Set icon and style
            if (type === 'success') {
                icon.textContent = '✓';
                icon.className = 'popup-icon success';
            } else {
                icon.textContent = '✕';
                icon.className = 'popup-icon error';
            }
            
            // Show popup
            overlay.classList.add('show');
        }

        function hidePopup() {
            const overlay = document.getElementById('popupOverlay');
            overlay.classList.remove('show');
        }

        function getSelectedTrainer() {
            const selectedTrainer = document.querySelector('.trainer-btn.selected');
            return selectedTrainer.dataset.trainer;
        }

        function getCurrentDate() {
            const selectedDateElement = document.querySelector('.calendar-date.selected');
            if (selectedDateElement && selectedDateElement.dataset.date) {
                // Убеждаемся, что дата в правильном формате YYYY-MM-DD
                const dateStr = selectedDateElement.dataset.date;
                return dateStr;
            }
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            return todayStr;
        }

        function getSelectedTimeSlot() {
            const selectedSlot = document.querySelector('.time-slot.selected');
            return selectedSlot ? selectedSlot.dataset.time : null;
        }

        // Создание Stripe Checkout сессии и редирект
        async function redirectToStripeCheckout(bookingData) {
            // Преобразуем total "1 197" -> 1197
            const amountAed = Number(String(bookingData.total).replace(/\s/g, ''));

            // Маска телефона: из dataset или, если нет, собираем из UI
            const uiDial = (document.querySelector('.phone-select-code')?.textContent || '').trim();
            const uiLocal = String(document.getElementById('clientPhone')?.value || '').replace(/\D/g, '');
            const maskedResolved = (document.getElementById('clientPhone')?.dataset?.masked)
                || (uiDial && uiLocal ? `${uiDial} ${uiLocal}` : '');

            // Определяем явные service_id/staff_id для прокидывания на бэкенд
            const selectedServiceId = getServiceIdForLocation(bookingData.location, bookingData.duration, bookingData.trainer);
            const selectedStaffId = getStaffIdForLocation(bookingData.location);

            const payload = {
                name: bookingData.name,
                phone: bookingData.phone,
                phone_masked: maskedResolved,
                location: bookingData.location,
                duration: bookingData.duration,
                trainer: bookingData.trainer,
                time: bookingData.time,
                date: bookingData.date,
                amount_aed: amountAed,
                return_url: window.location.href,
                timezone_offset_minutes: new Date().getTimezoneOffset() * -1,
                service_id: selectedServiceId,
                staff_id: selectedStaffId
            };

            // Telegram: старт оплаты
            try {
                // Если маска не пришла, соберем из UI
                let masked = payload.phone_masked || '';
                if (!masked) {
                    const dialUI = (document.querySelector('.phone-select-code')?.textContent || '').trim();
                    const localUI = String(document.getElementById('clientPhone')?.value || '').replace(/\D/g, '');
                    if (dialUI && localUI) masked = `${dialUI} ${localUI}`;
                    else masked = payload.phone || '';
                }
                const trainerLabel = payload.trainer === 'with' ? 'С тренером' : 'Без тренера';
                const message = `*Старт оплаты бронирования WakeMe*\n\n*Клиент:* ${payload.name || '-'}\n*Телефон:* ${masked || '-'}\n*Локация:* ${payload.location || '-'}\n*Длительность:* ${payload.duration || '-'} мин\n*Тренер:* ${trainerLabel}\n*Время:* ${payload.time || '-'}\n*Стоимость:* ${String(bookingData.total || '').toString()} AED\n*Дата:* ${payload.date || '-'}`;
                fetch(`${API_CONFIG.proxyUrl}/api/send-telegram`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                }).catch(() => {});
            } catch (_) {}

            // Клиентский лог
            try {
                fetch(`${API_CONFIG.proxyUrl}/api/logs`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ level: 'info', message: 'create-checkout-session:start', data: payload })
                });
            } catch (e) {}

            const response = await fetch(`${API_CONFIG.proxyUrl}/api/create-checkout-session`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const text = await response.text();
                try {
                    fetch(`${API_CONFIG.proxyUrl}/api/logs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ level: 'error', message: 'create-checkout-session:failed', data: { status: response.status, body: text } })
                    });
                } catch (e) {}
                throw new Error(text || 'Не удалось создать сессию Stripe');
            }

            const data = await response.json();
            if (data && data.url) {
                window.location.href = data.url;
            } else {
                try {
                    fetch(`${API_CONFIG.proxyUrl}/api/logs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ level: 'error', message: 'create-checkout-session:no-url', data: data })
                    });
                } catch (e) {}
                throw new Error('Не удалось получить URL Stripe');
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Popup button handler
            document.getElementById('popupButton').addEventListener('click', hidePopup);
            document.getElementById('popupOverlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    hidePopup();
                }
            });

            // Показ "успех" после возврата со Stripe (?paid=1) — защищаем флагом sessionStorage
            try {
                const params = new URLSearchParams(window.location.search);
                const cameFromStripe = Boolean(params.get('session_id')) || sessionStorage.getItem('stripe_flow') === 'started';
                if (params.get('paid') === '1' && cameFromStripe) {
                    showPopup('success', 'Оплата получена', 'Мы напишем вам в WhatsApp для уточнения деталей');
                    // Чистим URL, чтобы при обновлении модалка не всплывала снова
                    const url = new URL(window.location.href);
                    url.searchParams.delete('paid');
                    url.searchParams.delete('session_id');
                    history.replaceState({}, '', url.pathname + (url.search ? '?' + url.searchParams.toString() : '') + url.hash);
                    sessionStorage.removeItem('stripe_flow');
                } else {
                    // На всякий случай очищаем старый флаг
                    sessionStorage.removeItem('stripe_flow');
                }
            } catch (_) {}

            const phoneInput = document.getElementById('clientPhone');
            if (phoneInput) {
                // Кастомный контрол: галочка + код страны + ввод. Без флагов
                const PRIORITY = ['AE','RU','UA','GB','FR','KZ'];
                const COUNTRIES = [
                    { cc: 'AE', name: 'UAE', dial: '+971' },
                    { cc: 'RU', name: 'Russia', dial: '+7' },
                    { cc: 'UA', name: 'Ukraine', dial: '+380' },
                    { cc: 'KZ', name: 'Kazakhstan', dial: '+7' },
                    { cc: 'AM', name: 'Armenia', dial: '+374' },
                    { cc: 'AT', name: 'Austria', dial: '+43' },
                    { cc: 'AZ', name: 'Azerbaijan', dial: '+994' },
                    { cc: 'BY', name: 'Belarus', dial: '+375' },
                    { cc: 'BE', name: 'Belgium', dial: '+32' },
                    { cc: 'BA', name: 'Bosnia and Herzegovina', dial: '+387' },
                    { cc: 'BG', name: 'Bulgaria', dial: '+359' },
                    { cc: 'CA', name: 'Canada', dial: '+1' },
                    { cc: 'CN', name: 'China', dial: '+86' },
                    { cc: 'HR', name: 'Croatia', dial: '+385' },
                    { cc: 'CY', name: 'Cyprus', dial: '+357' },
                    { cc: 'CZ', name: 'Czechia', dial: '+420' },
                    { cc: 'DK', name: 'Denmark', dial: '+45' },
                    { cc: 'EE', name: 'Estonia', dial: '+372' },
                    { cc: 'FI', name: 'Finland', dial: '+358' },
                    { cc: 'FR', name: 'France', dial: '+33' },
                    { cc: 'GE', name: 'Georgia', dial: '+995' },
                    { cc: 'DE', name: 'Germany', dial: '+49' },
                    { cc: 'GR', name: 'Greece', dial: '+30' },
                    { cc: 'HU', name: 'Hungary', dial: '+36' },
                    { cc: 'IN', name: 'India', dial: '+91' },
                    { cc: 'IE', name: 'Ireland', dial: '+353' },
                    { cc: 'IL', name: 'Israel', dial: '+972' },
                    { cc: 'IT', name: 'Italy', dial: '+39' },
                    { cc: 'JP', name: 'Japan', dial: '+81' },
                    { cc: 'KG', name: 'Kyrgyzstan', dial: '+996' },
                    { cc: 'LV', name: 'Latvia', dial: '+371' },
                    { cc: 'LT', name: 'Lithuania', dial: '+370' },
                    { cc: 'LU', name: 'Luxembourg', dial: '+352' },
                    { cc: 'MD', name: 'Moldova', dial: '+373' },
                    { cc: 'ME', name: 'Montenegro', dial: '+382' },
                    { cc: 'NL', name: 'Netherlands', dial: '+31' },
                    { cc: 'NO', name: 'Norway', dial: '+47' },
                    { cc: 'PL', name: 'Poland', dial: '+48' },
                    { cc: 'PT', name: 'Portugal', dial: '+351' },
                    { cc: 'RO', name: 'Romania', dial: '+40' },
                    { cc: 'RS', name: 'Serbia', dial: '+381' },
                    { cc: 'SK', name: 'Slovakia', dial: '+421' },
                    { cc: 'SI', name: 'Slovenia', dial: '+386' },
                    { cc: 'ES', name: 'Spain', dial: '+34' },
                    { cc: 'SE', name: 'Sweden', dial: '+46' },
                    { cc: 'CH', name: 'Switzerland', dial: '+41' },
                    { cc: 'TR', name: 'Turkey', dial: '+90' },
                    { cc: 'GB', name: 'United Kingdom', dial: '+44' },
                    { cc: 'US', name: 'USA', dial: '+1' },
                    { cc: 'UZ', name: 'Uzbekistan', dial: '+998' }
                ];

                const sorted = [
                    ...COUNTRIES.filter(c => PRIORITY.includes(c.cc)),
                    ...COUNTRIES.filter(c => !PRIORITY.includes(c.cc)).sort((a,b) => a.name.localeCompare(b.name))
                ];

                const wrapper = document.createElement('div');
                wrapper.className = 'phone-input';

                const selectBtn = document.createElement('div');
                selectBtn.className = 'phone-select';
                const codeEl = document.createElement('span'); codeEl.className = 'phone-select-code'; codeEl.textContent = '+971';
                const caret = document.createElement('span'); caret.className = 'phone-caret';
                selectBtn.appendChild(codeEl); selectBtn.appendChild(caret);

                const dropdown = document.createElement('div');
                dropdown.className = 'phone-dropdown';
                sorted.forEach(item => {
                    const row = document.createElement('div');
                    row.className = 'phone-item';
                    row.dataset.cc = item.cc;
                    row.dataset.dial = item.dial;
                    row.innerHTML = `<span>${item.name}</span><span>${item.dial}</span>`;
                    row.addEventListener('click', () => {
                        codeEl.textContent = item.dial;
                        dropdown.classList.remove('show');
                        phoneInput.focus();
                    });
                    dropdown.appendChild(row);
                });

                const parent = phoneInput.parentElement;
                parent.replaceChildren();
                wrapper.appendChild(selectBtn);
                wrapper.appendChild(phoneInput);
                wrapper.appendChild(dropdown);
                parent.appendChild(wrapper);

                // Тоггл списка по клику на галочку/код
                selectBtn.addEventListener('click', () => dropdown.classList.toggle('show'));
                document.addEventListener('click', (e) => { if (!wrapper.contains(e.target)) dropdown.classList.remove('show'); });

                // Геодетект страны (дефолт AE)
                try {
                    fetch('https://ipapi.co/json/')
                        .then(r => r.json())
                        .then(d => {
                            const found = COUNTRIES.find(c => c.cc === (d && d.country_code));
                            if (found) codeEl.textContent = found.dial;
                        })
                        .catch(() => {});
                } catch(_) {}

                // Только цифры в локальной части
                phoneInput.addEventListener('input', function() {
                    const digits = this.value.replace(/\D/g, '');
                    if (this.value !== digits) this.value = digits;
                });

                // При сабмите — сохраняем маску, но не меняем значение поля
                document.getElementById('bookingForm').addEventListener('submit', function() {
                    const dial = codeEl.textContent || '';
                    const local = phoneInput.value || '';
                    phoneInput.dataset.masked = `${dial} ${local}`.trim();
                });
            }

            // Duration selection
            document.querySelectorAll('.duration-option').forEach(option => {
                option.addEventListener('click', function() {
                    
                    document.querySelectorAll('.duration-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    updateTrainerPrice(); // Обновляем цену тренера
                    clearAvailabilityCache(); // Очищаем кеш доступности при смене услуги
                    
                    // НОВАЯ АРХИТЕКТУРА: Событийная синхронизация
                    const selectedDuration = getSelectedDuration();
                    const selectedLocation = getSelectedLocation();
                    const cacheKey = `${selectedLocation}_${selectedDuration}`;
                    
                    
                    onServiceOrLocationChange({
                        cacheKey,
                        fetchAvailability,
                        renderCalendar: renderCalendarFromData,
                        highlightDate,
                        fetchSlots: loadSlotsSafe
                    });
                });
            });

            // Trainer selection
            document.querySelectorAll('.trainer-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.trainer-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });

            // Location selection
            document.querySelectorAll('.location-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    
                    document.querySelectorAll('.location-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    clearAvailabilityCache(); // Очищаем кеш доступности при смене локации
                    
                    // НОВАЯ АРХИТЕКТУРА: Событийная синхронизация
                    const selectedDuration = getSelectedDuration();
                    const selectedLocation = getSelectedLocation();
                    const cacheKey = `${selectedLocation}_${selectedDuration}`;
                    
                    
                    onServiceOrLocationChange({
                        cacheKey,
                        fetchAvailability,
                        renderCalendar: renderCalendarFromData,
                        highlightDate,
                        fetchSlots: loadSlotsSafe
                    });
                });
            });


            // Booking form submission
            document.getElementById('bookingForm').addEventListener('submit', async function(e) {
                e.preventDefault();

                const phoneInput = document.getElementById('clientPhone');
                if (phoneInput) {
                    // Оставляем только цифры в локальной части, не подставляя код страны в поле
                    phoneInput.value = phoneInput.value.replace(/\D/g, '');
                }

                const selectedTime = getSelectedTimeSlot();
                if (!selectedTime) {
                    showPopup('error', 'Выберите время', 'Пожалуйста, выберите время для бронирования');
                    return;
                }

                const bookingData = {
                    name: document.getElementById('clientName').value,
                    phone: document.getElementById('clientPhone').value,
                    location: getSelectedLocation(),
                    duration: getSelectedDuration(),
                    trainer: getSelectedTrainer(),
                    time: selectedTime,
                    date: getCurrentDate(),
                    total: calculateTotalPrice()
                };

                // Открываем модалку выбора способа оплаты
                const overlay = document.getElementById('paymentChoiceOverlay');
                overlay.classList.add('show');

                const onPayCard = async () => {
                    overlay.classList.remove('show');
                    const bookingBtn = document.getElementById('bookingBtn');
                    // Помечаем, что мы уходим в Stripe-флоу, чтобы по возврату корректно показать попап
                    try { sessionStorage.setItem('stripe_flow', 'started'); } catch(_) {}
                    bookingBtn.disabled = true;
                    bookingBtn.textContent = 'Отправка...';
                    try {
                        await redirectToStripeCheckout(bookingData);
                    } catch (error) {
                        showPopup('error', 'Ошибка оплаты', error.message || 'Не удалось перейти к оплате');
                    } finally {
                        bookingBtn.disabled = false;
                        bookingBtn.textContent = 'Забронировать';
                        cleanup();
                    }
                };

                const onPayLater = () => {
                    overlay.classList.remove('show');
                    // Формируем текст для WhatsApp
                    const trainerText = bookingData.trainer === 'with' ? 'С ТРЕНЕРОМ' : 'БЕЗ ТРЕНЕРА';
                    const text = `Добрый день! Хочу забронировать слот на ${bookingData.date} и ${bookingData.time}, на локации: ${bookingData.location}, ${bookingData.duration} МИНУТ ${trainerText}`;
                    const url = `https://wa.me/971553560352?text=${encodeURIComponent(text)}`;
                    window.open(url, '_blank');
                    cleanup();
                };

                const onCloseOverlay = (e) => {
                    if (e.target === overlay) {
                        overlay.classList.remove('show');
                        cleanup();
                    }
                };

                const onCloseBtn = () => {
                    overlay.classList.remove('show');
                    cleanup();
                };

                function cleanup() {
                    document.getElementById('payCardBtn').removeEventListener('click', onPayCard);
                    document.getElementById('payLaterBtn').removeEventListener('click', onPayLater);
                    overlay.removeEventListener('click', onCloseOverlay);
                    document.getElementById('paymentCloseBtn')?.removeEventListener('click', onCloseBtn);
                }

                document.getElementById('payCardBtn').addEventListener('click', onPayCard);
                document.getElementById('payLaterBtn').addEventListener('click', onPayLater);
                overlay.addEventListener('click', onCloseOverlay);
                document.getElementById('paymentCloseBtn')?.addEventListener('click', onCloseBtn);
            });
        });

        // Calendar variables
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();
        
        // Cache for date availability
        let dateAvailabilityCache = new Map();
        
        // Clear availability cache when location or service changes
        function clearAvailabilityCache() {
            dateAvailabilityCache.clear();
            // Также очищаем кэш ближайших дат
            nearestAvailableDates.clear();
            availableDatesCache.clear();
        }
        
        // Check if slots are available for a specific date
        async function checkDateAvailability(dateString) {
            
            // Check cache first
            if (dateAvailabilityCache.has(dateString)) {
                const cached = dateAvailabilityCache.get(dateString);
                return cached;
            }
            
            try {
                const locationKey = getSelectedLocation();
                const durationId = getSelectedDuration();
                const serviceId = getServiceIdForLocation(locationKey, durationId, getSelectedTrainer());
                const staffId = getStaffIdForLocation(locationKey);
                const companyId = API_CONFIG.companyId;
                
                const response = await fetch(`${API_CONFIG.proxyUrl}/api/slots?companyId=${companyId}&staffId=${staffId}&serviceId=${serviceId}&date=${dateString}`);
                
                if (!response.ok) {
                    // Для ошибок 422 (нет слотов) и других ошибок считаем дату недоступной
                    dateAvailabilityCache.set(dateString, false);
                    return false;
                }
                
                const data = await response.json();
                const hasSlots = data.success && data.data && Array.isArray(data.data) && data.data.length > 0;
                
                
                // Cache the result
                dateAvailabilityCache.set(dateString, hasSlots);
                return hasSlots;
                
            } catch (error) {
                // При любой ошибке считаем дату недоступной
                dateAvailabilityCache.set(dateString, false);
                return false;
            }
        }

        // Calendar navigation
        function changeMonth(direction) {
            
            // Сохраняем текущую выбранную дату
            const currentSelectedDate = document.querySelector('.calendar-date.selected');
            const selectedDate = currentSelectedDate ? currentSelectedDate.dataset.date : null;
            
            const today = new Date();
            const currentDate = new Date(currentYear, currentMonth);
            const todayDate = new Date(today.getFullYear(), today.getMonth());
            
            currentMonth += direction;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            } else if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            }
            
            // Check if we're trying to go to a past month
            const newDate = new Date(currentYear, currentMonth);
            if (newDate < todayDate) {
                // Revert the change
                currentMonth -= direction;
                if (currentMonth < 0) {
                    currentMonth = 11;
                    currentYear--;
                } else if (currentMonth > 11) {
                    currentMonth = 0;
                    currentYear++;
                }
                return; // Don't render if we can't go to past month
            }
            
            
            // Получаем данные для нового месяца
            const selectedDuration = getSelectedDuration();
            const selectedLocation = getSelectedLocation();
            const cacheKey = `${selectedLocation}_${selectedDuration}`;
            
            // Показываем скелет сразу
            const calendarGrid = document.querySelector('.calendar-grid');
            if (calendarGrid) {
                calendarGrid.innerHTML = '';
                const firstDayOfMonth = new Date(currentYear, currentMonth, 1).getDay();
                const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
                
                // Создаем пустые ячейки для начала месяца
                for (let i = 0; i < firstDayOfMonth; i++) {
                    const emptyCell = document.createElement('div');
                    emptyCell.className = 'calendar-date empty';
                    calendarGrid.appendChild(emptyCell);
                }
                
                // Создаем даты со скелетом СРАЗУ (БЕЗ ТЕКСТА - только блюренные круги)
                for (let i = 1; i <= daysInMonth; i++) {
                    const dateElement = document.createElement('div');
                    dateElement.className = 'calendar-date skeleton';
                    // НЕ добавляем textContent - только скелет
                    calendarGrid.appendChild(dateElement);
                }
            }
            
            // Также показываем скелет для времени при смене месяца
            const timeSlotsContainer = document.querySelector('.time-slots-grid');
            if (timeSlotsContainer) {
                timeSlotsContainer.innerHTML = '';
                
                // Создаем 3-4 скелета для времени
                for (let i = 0; i < 4; i++) {
                    const skeletonSlot = document.createElement('div');
                    skeletonSlot.className = 'time-slot skeleton';
                    timeSlotsContainer.appendChild(skeletonSlot);
                }
            }
            
            // Загружаем данные для нового месяца
            fetchAvailability({ signal: new AbortController().signal }).then(availability => {
                renderCalendarFromData(availability);
            }).catch(error => {
                // Fallback - показываем ошибку
                const calendarGrid = document.querySelector('.calendar-grid');
                if (calendarGrid) {
                    calendarGrid.innerHTML = `
                        <div class="form-error">
                            <div class="form-error-icon">⚠️</div>
                            <div class="form-error-title">Ошибка загрузки</div>
                            <div class="form-error-description">Не удалось загрузить календарь</div>
                        </div>
                    `;
                }
            });
            
            // Новая система не требует ожидания - все работает через Promise.all в renderCalendarFromData
        }

        // renderCalendar удалена - используется только renderCalendarFromData
        function renderCalendar() {
            return;
            const calendarGrid = document.querySelector('.calendar-grid');
            const calendarMonthDisplay = document.querySelector('.calendar-month');
            
            if (!calendarGrid || !calendarMonthDisplay) {
                return;
            }
            
            calendarGrid.innerHTML = ''; // Очищаем перед показом скелета
            // Показываем скелет анимацию для календаря
            calendarGrid.innerHTML = `
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
                <div class="calendar-date skeleton"></div>
            `;

            // Показываем скелетон сразу, без задержки
            
            // Используем requestAnimationFrame для показа скелетона в следующем кадре
            requestAnimationFrame(() => {
                // Очищаем скелет перед рендерингом реальных дат
                calendarGrid.innerHTML = '';
                
                const firstDayOfMonth = new Date(currentYear, currentMonth, 1).getDay();
                const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

                calendarMonthDisplay.textContent = `${new Date(currentYear, currentMonth).toLocaleString('ru-RU', { month: 'long' })} ${currentYear}`;

                // Days of week
                const daysOfWeek = ['ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'СБ', 'ВС'];
                daysOfWeek.forEach(day => {
                    const dayElement = document.createElement('div');
                    dayElement.className = 'calendar-day';
                    dayElement.textContent = day;
                    calendarGrid.appendChild(dayElement);
                });

                // Adjust first day to be Monday (0 for Sunday, 1 for Monday, etc.)
                let startDay = firstDayOfMonth === 0 ? 6 : firstDayOfMonth - 1;

                // Add empty divs for days before the 1st
                for (let i = 0; i < startDay; i++) {
                    const emptyDate = document.createElement('div');
                    emptyDate.className = 'calendar-date other-month';
                    const prevMonthDays = new Date(currentYear, currentMonth, 0).getDate();
                    emptyDate.textContent = prevMonthDays - startDay + i + 1;
                    calendarGrid.appendChild(emptyDate);
                }

                // Add days of the current month
                for (let i = 1; i <= daysInMonth; i++) {
                    const dateElement = document.createElement('div');
                    const cellDate = new Date(currentYear, currentMonth, i);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const isPastDate = cellDate < today;
                
                    dateElement.className = 'calendar-date';
                    dateElement.textContent = i;
                    dateElement.dataset.date = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${i.toString().padStart(2, '0')}`;
                    
                    // Проверяем, нужно ли заблокировать дату
                    const dateString = dateElement.dataset.date;
                    const isBeforeNearest = isDateBeforeNearestAvailable(dateString);
                    const shouldDisable = isPastDate || isBeforeNearest;
                    
                    
                    if (shouldDisable) {
                        dateElement.classList.add('disabled');
                        dateElement.style.opacity = '0.3';
                        dateElement.style.cursor = 'not-allowed';
                    } else {
                        // Check availability for non-disabled dates
                        checkDateAvailability(dateString).then(hasSlots => {
                            if (!hasSlots) {
                                dateElement.classList.add('no-slots');
                            }
                        });
                        
                        // НЕ выделяем сегодняшнюю дату автоматически - это будет сделано после загрузки данных о доступности
                        // const hasSelectedDate = document.querySelector('.calendar-date.selected');
                        // if (i === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear() && !hasSelectedDate) {
                        //     dateElement.classList.add('selected');
                        // }

                        dateElement.addEventListener('click', function() {
                            // Don't allow clicking on dates without slots
                            if (this.classList.contains('no-slots')) {
                                return;
                            }
                            
                            selectDate(this, dateString);
                            
                            // Загружаем слоты новым способом с AbortController
                            const abortController = new AbortController();
                            loadSlotsSafe(dateString, { signal: abortController.signal }).catch(error => {
                            });
                        });
                    }
                    
                    calendarGrid.appendChild(dateElement);
                }
                
                // НЕ устанавливаем дефолтную дату здесь - это делается в инициализации
            }); // Показываем скелетон сразу через requestAnimationFrame
        }

        function setDefaultSelections() {
            
            // Сначала убираем все выделения
            document.querySelectorAll('.duration-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelectorAll('.trainer-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            // Выбираем 60 минут по умолчанию
            const duration60 = document.querySelector('.duration-option[data-duration="60"]');
            if (duration60) {
                duration60.classList.add('selected');
            } else {
            }

            // Выбираем "с тренером" по умолчанию
            const withTrainer = document.querySelector('.trainer-btn[data-trainer="with"]');
            if (withTrainer) {
                withTrainer.classList.add('selected');
            } else {
            }

            // Обновляем цену тренера для выбранной услуги
            updateTrainerPrice();
            
            // НЕ устанавливаем дату здесь - она будет установлена после загрузки данных о доступности
        }

        // Установить дефолтную дату (ближайшую доступную)
        function setDefaultDate() {
            return new Promise((resolve) => {
            sendLogToServer('SET_DEFAULT_DATE', 'Вызов setDefaultDate', {
                stack: new Error().stack.split('\n').slice(0, 5)
            });
            const selectedLocation = getSelectedLocation();
            const selectedDuration = getSelectedDuration();
            const cacheKey = `${selectedLocation}_${selectedDuration}`;
            
            sendLogToServer('SET_DEFAULT_DATE', `Начинаем установку дефолтной даты для ${cacheKey}`);
            
            // АГРЕССИВНОЕ ожидание загрузки данных о доступности для мобилок
            const waitForAvailabilityData = () => {
                return new Promise((availabilityResolve) => {
                    let attempts = 0;
                    const maxAttempts = 50; // 5 секунд максимум
                    
                    const checkAvailability = () => {
                        attempts++;
                        
                        // Проверяем, что календарь отрендерен и есть данные о доступности
                        const calendarDates = document.querySelectorAll('.calendar-date:not(.disabled)');
                        const hasAvailabilityData = calendarDates.length > 0;
                        
                        // Дополнительная проверка - есть ли данные в кэше
                        const selectedLocation = getSelectedLocation();
                        const selectedDuration = getSelectedDuration();
                        const cacheKey = `${selectedLocation}_${selectedDuration}`;
                        const hasCacheData = nearestAvailableDates.has(cacheKey);
                        
                        
                        if (hasAvailabilityData && hasCacheData) {
                            availabilityResolve();
                        } else if (attempts >= maxAttempts) {
                            availabilityResolve();
                        } else {
                            setTimeout(checkAvailability, 100);
                        }
                    };
                    checkAvailability();
                });
            };
            
            waitForAvailabilityData().then(() => {
                // ДОПОЛНИТЕЛЬНАЯ задержка для мобильных устройств
                setTimeout(() => {
                    let defaultDate = null;
            
            // Если есть данные о ближайших датах, используем их
            if (nearestAvailableDates.has(cacheKey)) {
                const nearestData = nearestAvailableDates.get(cacheKey);
                
                if (nearestData && nearestData.data && nearestData.data.seance_date) {
                    const nearestDateStr = nearestData.data.seance_date.split('T')[0];
                    defaultDate = nearestDateStr;
                } else {
                }
            } else {
                // Fallback на сегодняшнюю дату, если кэш пуст
                const today = new Date();
                defaultDate = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;
            }
            
            if (!defaultDate) {
                resolve();
                return;
            }
            
            // Находим и выделяем элемент календаря
            const dateElement = document.querySelector(`.calendar-date[data-date="${defaultDate}"]`);
            
            if (dateElement) {
                
                if (!dateElement.classList.contains('disabled')) {
                    // Убираем выделение с других дат
                    selectDate(dateElement, defaultDate);
                    resolve();
                } else {
                    
                    // Ищем следующую доступную дату
                    const allDates = Array.from(document.querySelectorAll('.calendar-date:not(.disabled)'));
                    const sortedDates = allDates
                        .map(el => ({ element: el, date: el.dataset.date }))
                        .filter(item => item.date >= defaultDate)
                        .sort((a, b) => a.date.localeCompare(b.date));
                    
                    if (sortedDates.length > 0) {
                        const nextAvailableDate = sortedDates[0];
                        nextAvailableDate.element.classList.add('selected');
                    } else {
                    }
                    resolve();
                }
            } else {
                resolve();
            }
            
            // Финальная проверка выбранной даты
            const finalSelectedDate = document.querySelector('.calendar-date.selected');
            if (finalSelectedDate) {
                // Дата выбрана
            } else {
                // Дата не выбрана
            }
                }, 500); // Дополнительная задержка для мобилок
            });
            });
        }

        // ===== НОВАЯ АРХИТЕКТУРА: СОБЫТИЙНАЯ СИНХРОНИЗАЦИЯ =====
        
        // Двойной rAF — гарантированно после layout+paint
        const afterPaint = () => new Promise(r =>
            requestAnimationFrame(() => requestAnimationFrame(r))
        );

        // Защита от гонок
        let runId = 0;
        let isInitializing = false;
        const newRun = () => (++runId);
        const isStale = (id) => id !== runId;

        // Хранилище доступности по cacheKey как промис
        const availabilityStore = new Map(); // cacheKey -> Promise<Availability>

        function getAvailability(cacheKey, fetchFn, signal) {
            if (!availabilityStore.has(cacheKey)) {
                const p = fetchFn({ signal }).then(data => {
                    if (!data || !Array.isArray(data.dates)) throw new Error('bad data');
                    return data;
                });
                availabilityStore.set(cacheKey, p);
            }
            return availabilityStore.get(cacheKey);
        }

        // Унифицированный адаптер для слотов - всегда возвращает Slot[]
        async function fetchSlots(dateISO, { signal }) {
            
            const selectedDuration = getSelectedDuration();
            const selectedLocation = getSelectedLocation();
            const serviceId = getServiceIdForLocation(selectedLocation, selectedDuration, getSelectedTrainer());
            
            try {
                const response = await fetch(`${API_CONFIG.proxyUrl}/api/slots?companyId=${API_CONFIG.companyId}&staffId=${API_CONFIG.locations[selectedLocation].staffId}&serviceId=${serviceId}&date=${dateISO}`, {
                    signal
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const json = await response.json();
                
                // Адаптер: на переходный период поддерживаем оба формата
                const slots = Array.isArray(json) ? json : json.data;
                
                return slots;
            } catch (error) {
                throw error;
            }
        }

        // Безопасный загрузчик слотов с отменой (использует унифицированный адаптер)
        async function loadSlotsSafe(dateISO, { signal }) {
            
            try {
                const slots = await fetchSlots(dateISO, { signal });
                
                // Рендерим слоты времени
                renderTimeSlots(slots);
                
                return slots;
            } catch (error) {
                throw error; // Пробрасываем ошибку дальше
            }
        }

        // Рендер слотов времени
        function renderTimeSlots(slots) {
            
            const timeSlots = document.querySelector('.time-slots-grid');
            if (!timeSlots) return;
            
            if (!slots || !Array.isArray(slots) || slots.length === 0) {
                timeSlots.innerHTML = `
                    <div class="form-error">
                        <div class="form-error-icon">⚠️</div>
                        <div class="form-error-title">Нет доступных слотов</div>
                        <div class="form-error-description">Попробуйте выбрать другую дату</div>
                    </div>
                `;
                return;
            }
            
            timeSlots.innerHTML = slots.map(slot => `
                <div class="time-slot" data-time="${slot.time}">
                    ${slot.time}
                </div>
            `).join('');
            
            // Добавляем обработчики клика
            timeSlots.querySelectorAll('.time-slot').forEach(slot => {
                slot.addEventListener('click', function() {
                    document.querySelectorAll('.time-slot').forEach(s => s.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
        }

        // Ожидание DOM элемента с таймаутом
        function waitFor(selector, { root = document, timeout = 5000 } = {}) {
            return new Promise((resolve, reject) => {
                const found = root.querySelector(selector);
                if (found) return resolve(found);

                const obs = new MutationObserver(() => {
                    const el = root.querySelector(selector);
                    if (el) { obs.disconnect(); resolve(el); }
                });
                obs.observe(root, { childList: true, subtree: true });

                const t = setTimeout(() => {
                    obs.disconnect();
                    resolve(null); // не reject — UI должен деградировать мягко
                }, timeout);
            });
        }

        // Централизованная функция для выбора даты
        function selectDate(dateElement, dateString = null) {
            
            // КРИТИЧНО: Убираем ВСЕ выделения с ВСЕХ дат
            document.querySelectorAll('.calendar-date').forEach(d => {
                d.classList.remove('selected');
            });
            
            // Выделяем только выбранную дату
            dateElement.classList.add('selected');
            
            
            // Проверяем, что только одна дата выбрана
            const selectedDates = document.querySelectorAll('.calendar-date.selected');
            if (selectedDates.length > 1) {
                // Принудительно исправляем
                selectedDates.forEach((d, index) => {
                    if (index > 0) {
                        d.classList.remove('selected');
                    }
                });
            }
        }

        // ===== НОВЫЙ ПОТОК ИНИЦИАЛИЗАЦИИ =====
        
        // Функция получения доступности из API
        async function fetchAvailability({ signal }) {
            
            const selectedDuration = getSelectedDuration();
            const selectedLocation = getSelectedLocation();
            const serviceId = getServiceIdForLocation(selectedLocation, selectedDuration, getSelectedTrainer());
            
            try {
                const response = await fetch(`https://wakeme-booking-api-production.up.railway.app/api/availability`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        service_id: serviceId,
                        start_date: new Date().toISOString().split('T')[0],
                        end_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
                    }),
                    signal
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                
                // Преобразуем в нужный формат
                const dates = (data.available_dates || []).map(date => ({
                    dateISO: date,
                    hasFreeSlots: true, // Пока считаем доступными, реальная проверка будет в checkDateAvailability
                    slotsCount: 0 // Будет заполнено при загрузке слотов
                }));
                
                
                
                return {
                    dates
                };
            } catch (error) {
                throw error; // Пробрасываем ошибку дальше
            }
        }

        // Рендер календаря из данных (детерминированный)
        function renderCalendarFromData(availability) {
            
            const calendarGrid = document.querySelector('.calendar-grid');
            const calendarMonthDisplay = document.querySelector('.calendar-month');
            
            // Очищаем календарь и создаем заново
            calendarGrid.innerHTML = '';
            
            const firstDayOfMonth = new Date(currentYear, currentMonth, 1).getDay();
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
            
            calendarMonthDisplay.textContent = `${new Date(currentYear, currentMonth).toLocaleString('ru-RU', { month: 'long' })} ${currentYear}`;
            
            // Создаем пустые ячейки для начала месяца
            for (let i = 0; i < firstDayOfMonth; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.className = 'calendar-date empty';
                calendarGrid.appendChild(emptyCell);
            }
            
            // Создаем даты со скелетом СРАЗУ
            const dateElements = [];
            for (let i = 1; i <= daysInMonth; i++) {
                const dateElement = document.createElement('div');
                dateElement.className = 'calendar-date skeleton';
                // НЕ добавляем textContent - только скелет
                dateElements.push(dateElement);
                calendarGrid.appendChild(dateElement);
            }
            
            
            // НОВЫЙ ПОДХОД: Создаем все промисы сразу, без пакетной обработки
            const availabilityPromises = [];
            const availableDates = [];
            
            // Проходим по всем датам и создаем промисы
            for (let i = 0; i < dateElements.length; i++) {
                const dateElement = dateElements[i];
                
                // Устанавливаем правильную дату для элемента
                const date = new Date(currentYear, currentMonth, i + 1);
                const dateString = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${(i + 1).toString().padStart(2, '0')}`;
                dateElement.dataset.date = dateString;
                
                // Проверяем доступность из данных API
                const isAvailable = availability.dates.some(d => d.dateISO === dateString && d.hasFreeSlots);
                
                
                if (!isAvailable) {
                    // Дата недоступна - убираем скелет и блокируем
                    dateElement.classList.remove('skeleton');
                    dateElement.classList.add('disabled');
                    dateElement.textContent = i + 1; // Добавляем номер даты
                } else {
                    // Дата доступна - проверяем реальную доступность слотов
                    const availabilityPromise = checkDateAvailability(dateString).then(hasSlots => {
                        // Убираем скелет
                        dateElement.classList.remove('skeleton');
                        dateElement.textContent = i + 1; // Добавляем номер даты
                        
                        if (!hasSlots) {
                            dateElement.classList.add('no-slots');
                            return { dateString, hasSlots: false };
                        } else {
                            return { dateString, hasSlots: true };
                        }
                    }).catch(error => {
                        // Убираем скелет и блокируем дату
                        dateElement.classList.remove('skeleton');
                        dateElement.classList.add('no-slots');
                        dateElement.textContent = i + 1; // Добавляем номер даты
                        return { dateString, hasSlots: false };
                    });
                    
                    availabilityPromises.push(availabilityPromise);
                }
            }
            
            
            // Ждем завершения всех проверок доступности + добавляем задержку
            if (availabilityPromises.length > 0) {
                Promise.all(availabilityPromises).then(async results => {
                    
                    // Ждем завершения отрисовки
                    await afterPaint();
                    
                    // Находим ближайшую доступную дату
                    const availableDates = results.filter(r => r && r.hasSlots).sort((a, b) => a.dateString.localeCompare(b.dateString));
                    
                    
                    if (availableDates.length > 0) {
                        const nearestDate = availableDates[0].dateString;
                        
                        // Выделяем ближайшую доступную дату
                        const nearestDateElement = document.querySelector(`.calendar-date[data-date="${nearestDate}"]`);
                        if (nearestDateElement && !nearestDateElement.classList.contains('skeleton')) {
                            // Выбираем дату
                            selectDate(nearestDateElement, nearestDate);
                            
                            // Загружаем слоты новым способом с AbortController
                            const abortController = new AbortController();
                            loadSlotsSafe(nearestDate, { signal: abortController.signal }).catch(error => {
                            });
                        } else {
                        }
                    } else {
                    }
                });
            } else {
            }
            
            // Добавляем обработчики клика для всех дат
            dateElements.forEach(dateElement => {
                // Убираем старые обработчики
                dateElement.removeEventListener('click', dateElement._clickHandler);
                
                // Добавляем новый обработчик
                dateElement._clickHandler = () => {
                    if (dateElement.classList.contains('disabled') || 
                        dateElement.classList.contains('no-slots') || 
                        dateElement.classList.contains('skeleton')) return;
                    
                    const dateString = dateElement.dataset.date;
                    selectDate(dateElement, dateString);
                    
                    // Загружаем слоты новым способом с AbortController
                    const abortController = new AbortController();
                    loadSlotsSafe(dateString, { signal: abortController.signal }).catch(error => {
                    });
                };
                
                dateElement.addEventListener('click', dateElement._clickHandler);
            });
        }

        // Выделение даты (чистая функция)
        function highlightDate(dateISO) {
            
            const dateElement = document.querySelector(`.calendar-date[data-date="${dateISO}"]`);
            if (dateElement && !dateElement.classList.contains('disabled')) {
                selectDate(dateElement, dateISO);
            }
        }

        // Основная функция инициализации с событийной синхронизацией
        async function initBooking({ cacheKey, fetchAvailability, renderCalendar, highlightDate, fetchSlots, savedDate }) {
            // Предотвращаем множественные инициализации
            if (isInitializing) {
                return;
            }
            
            isInitializing = true;
            const myRun = newRun();
            const controller = new AbortController();
            const { signal } = controller;


            try {
                // 1) Тянем данные. Никаких setTimeout.
                const availabilityPromise = getAvailability(cacheKey, fetchAvailability, signal);

                // 2) Ждем данные и первый paint календаря
                const [availability] = await Promise.all([
                    availabilityPromise,
                    waitFor('.calendar-grid')
                ]);
                
                if (isStale(myRun)) {
                    return;
                }


                // 3) Рендерим календарь строго из данных, не из DOM
                renderCalendarFromData(availability);
                await afterPaint();
                if (isStale(myRun)) return;

                // 4) НЕ ВЫБИРАЕМ ДАТУ ЗДЕСЬ - это будет сделано в renderCalendarFromData

                // Возвращаем функцию отмены
                return () => {
                    controller.abort();
                };

            } catch (error) {
                if (error.name === 'AbortError') {
                } else {
                }
            } finally {
                // Сбрасываем флаг инициализации
                isInitializing = false;
            }
        }

        // Глобальная переменная для отмены
        let cancelCurrent = null;

        // Обработчик смены услуги/локации без гонок
        async function onServiceOrLocationChange({ cacheKey, ...deps }) {
            
            // Сохраняем текущую выбранную дату
            const currentSelectedDate = document.querySelector('.calendar-date.selected');
            const savedDate = currentSelectedDate ? currentSelectedDate.dataset.date : null;
            
            // СРАЗУ показываем скелет для календаря при смене
            const calendarGrid = document.querySelector('.calendar-grid');
            if (calendarGrid) {
                const dateElements = calendarGrid.querySelectorAll('.calendar-date:not(.empty)');
                dateElements.forEach(dateElement => {
                    dateElement.classList.add('skeleton');
                    dateElement.classList.remove('selected', 'disabled', 'no-slots');
                    dateElement.textContent = ''; // Убираем текст для скелета
                });
            }
            
            // Также показываем скелет для времени при смене
            const timeSlotsContainer = document.querySelector('.time-slots-grid');
            if (timeSlotsContainer) {
                timeSlotsContainer.innerHTML = '';
                
                // Создаем 3-4 скелета для времени
                for (let i = 0; i < 4; i++) {
                    const skeletonSlot = document.createElement('div');
                    skeletonSlot.className = 'time-slot skeleton';
                    timeSlotsContainer.appendChild(skeletonSlot);
                }
            }
            
            if (cancelCurrent) {
                cancelCurrent(); // мгновенно гасим старые запросы
            }
            
            cancelCurrent = await initBooking({ cacheKey, ...deps, savedDate });
        }

        // afterPaint уже определен выше

        // Отправка логов на сервер
        function sendLogToServer(level, message, data = {}) {
            const logData = {
                level: level,
                message: message,
                data: data,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                url: window.location.href
            };
            
            // Отправляем на сервер
            fetch('https://wakeme-booking-api-production.up.railway.app/api/logs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(logData)
            }).catch(err => {
            });
            
            // Также выводим в консоль
        }


        // Initialize
        // НОВАЯ АРХИТЕКТУРА: Инициализация с событийной синхронизацией
        
        // Скелет будет показан в renderCalendarFromData
        // Но сразу показываем скелет времени при инициализации
        const timeSlotsContainer = document.querySelector('.time-slots-grid');
        if (timeSlotsContainer) {
            timeSlotsContainer.innerHTML = '';
            
            // Создаем 4-5 скелетов для времени
            for (let i = 0; i < 5; i++) {
                const skeletonSlot = document.createElement('div');
                skeletonSlot.className = 'time-slot skeleton';
                timeSlotsContainer.appendChild(skeletonSlot);
            }
        }
        
        // Защита от ошибок внешних скриптов Tilda
        window.addEventListener('error', function(e) {
            if (e.message.includes('initScrollBooster') || e.message.includes('children')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Устанавливаем дефолтные значения
        setDefaultSelections();
        
        // Инициализируем с новой архитектурой
        const selectedDuration = getSelectedDuration();
        const selectedLocation = getSelectedLocation();
        const cacheKey = `${selectedLocation}_${selectedDuration}`;
        
        
        initBooking({
            cacheKey,
            fetchAvailability,
            renderCalendar: renderCalendarFromData,
            highlightDate,
            fetchSlots: loadSlotsSafe
        }).then((cancelFn) => {
            if (cancelFn) {
                cancelCurrent = cancelFn;
            }
        }).catch(error => {
            
            // Показываем ошибку пользователю
            const calendarGrid = document.querySelector('.calendar-grid');
            if (calendarGrid) {
                calendarGrid.innerHTML = `
                    <div class="form-error">
                        <div class="form-error-icon">⚠️</div>
                        <div class="form-error-title">Ошибка загрузки данных</div>
                        <div class="form-error-description">Не удалось подключиться к серверу. Проверьте подключение к интернету.</div>
                    </div>
                `;
            }
            
            const timeSlots = document.querySelector('.time-slots-grid');
            if (timeSlots) {
                timeSlots.innerHTML = `
                    <div class="form-error">
                        <div class="form-error-icon">⚠️</div>
                        <div class="form-error-title">Нет доступных слотов</div>
                        <div class="form-error-description">Попробуйте обновить страницу</div>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>